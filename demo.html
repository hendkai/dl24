<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATorch DL24P - 18650 Test Manager</title>
    <style>
        :root {
            --color-bg: #1a1a2e;
            --color-surface: #16213e;
            --color-primary: #0f3460;
            --color-accent: #e94560;
            --color-success: #00d9ff;
            --color-text: #eaeaea;
            --color-text-dim: #a0a0a0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--color-surface);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        h1 {
            color: var(--color-success);
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .subtitle {
            color: var(--color-text-dim);
            font-size: 1.1rem;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 968px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: var(--color-surface);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .card h2 {
            color: var(--color-success);
            margin-bottom: 20px;
            font-size: 1.5rem;
            border-bottom: 2px solid var(--color-primary);
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: var(--color-text);
            font-weight: 500;
        }

        input, select {
            width: 100%;
            padding: 12px;
            background: var(--color-primary);
            border: 2px solid var(--color-primary);
            border-radius: 8px;
            color: var(--color-text);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--color-success);
            background: rgba(0, 217, 255, 0.1);
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: var(--color-success);
            color: var(--color-bg);
        }

        .btn-primary:hover {
            background: #00b8d4;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 217, 255, 0.4);
        }

        .btn-danger {
            background: var(--color-accent);
            color: white;
        }

        .btn-danger:hover {
            background: #c23854;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(233, 69, 96, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .status-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .status-item {
            background: var(--color-primary);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .status-label {
            font-size: 0.9rem;
            color: var(--color-text-dim);
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--color-success);
        }

        .status-unit {
            font-size: 1rem;
            color: var(--color-text-dim);
            margin-left: 5px;
        }

        #log {
            background: var(--color-bg);
            padding: 15px;
            border-radius: 8px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            border: 2px solid var(--color-primary);
        }

        .log-entry {
            padding: 5px;
            border-bottom: 1px solid var(--color-primary);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .log-info { color: var(--color-success); }
        .log-warning { color: #ffd700; }
        .log-error { color: var(--color-accent); }
        .log-data { color: var(--color-text-dim); }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: var(--color-primary);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--color-success), #00b8d4);
            width: 0%;
            transition: width 0.5s ease;
        }

        .progress-bar::after {
            content: attr(data-progress);
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            color: var(--color-text);
            font-weight: bold;
            font-size: 0.9rem;
            text-shadow: 0 0 3px var(--color-bg);
        }

        .chart-container {
            margin-top: 20px;
            background: var(--color-bg);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid var(--color-primary);
        }

        canvas {
            width: 100% !important;
            height: 400px !important; /* Increased height for better resolution */
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
        }

        /* System Status Styles */
        .system-status {
            background: var(--color-bg);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid var(--color-primary);
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 217, 255, 0.1);
        }

        .status-row:last-child {
            border-bottom: none;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .indicator-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #666;
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
        }

        .indicator-dot.connected {
            background: var(--color-success);
            box-shadow: 0 0 10px var(--color-success);
        }

        .indicator-dot.disconnected {
            background: var(--color-danger);
            box-shadow: 0 0 10px var(--color-danger);
        }

        .indicator-dot.active {
            background: var(--color-warning);
            box-shadow: 0 0 15px var(--color-warning);
            animation: pulse 1s infinite;
        }

        .indicator-dot.inactive {
            background: #666;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .indicator-label {
            color: var(--color-text);
            font-weight: 500;
        }

        .status-value {
            color: var(--color-success);
            font-family: monospace;
            font-weight: bold;
        }

        /* Enhanced button states */
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn:disabled:hover {
            transform: none !important;
        }

        .btn.btn-loading {
            background: linear-gradient(45deg, var(--color-warning), var(--color-success));
            animation: button-loading 1s infinite;
        }

        @keyframes button-loading {
            0% { opacity: 1; }
            50% { opacity: 0.8; }
            100% { opacity: 1; }
        }

        @keyframes warning-pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
            }
            50% {
                transform: scale(1.02);
                box-shadow: 0 0 20px rgba(255, 170, 0, 0.8);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
            }
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .preset-btn {
            padding: 10px;
            background: var(--color-primary);
            border: 2px solid var(--color-success);
            border-radius: 8px;
            color: var(--color-text);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .preset-btn:hover {
            background: var(--color-success);
            color: var(--color-bg);
            transform: scale(1.05);
        }

        .phase-item {
            background: var(--color-bg);
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 3px solid var(--color-success);
        }

        .phase-header {
            font-weight: bold;
            color: var(--color-success);
            margin-bottom: 5px;
        }

        .phase-details {
            color: var(--color-text-dim);
            font-size: 0.9rem;
            margin-left: 10px;
        }

        .cycle-param {
            display: inline-block;
            margin-right: 15px;
            padding: 3px 8px;
            background: rgba(0, 217, 255, 0.1);
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .info-box {
            background: rgba(0, 217, 255, 0.1);
            border-left: 4px solid var(--color-success);
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .warning-box {
            background: rgba(255, 215, 0, 0.1);
            border-left: 4px solid #ffd700;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            color: #ffd700;
        }
    </style>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ö° ATorch DL24P - 18650 Test Manager</h1>
            <p class="subtitle">Automated 18650 Li-Ion battery discharge testing with data logging and visualization</p>
        </header>

        <div class="grid">
            <div class="card">
                <h2>üîã Test Parameters</h2>
                
                <div class="form-group">
                    <label for="batteryType">Battery Type</label>
                    <select id="batteryType">
                        <option value="liion" selected>18650 Li-Ion (2.5V - 4.2V)</option>
                        <option value="custom">Custom Settings</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="dischargeCurrent">Discharge Current (A)</label>
                    <input type="number" id="dischargeCurrent" value="1.0" min="0.1" max="20" step="0.1">
                </div>

                <div class="form-group">
                    <label for="cutoffVoltage">Cut-off Voltage (V)</label>
                    <input type="number" id="cutoffVoltage" value="2.5" min="0.1" max="60" step="0.1">
                </div>

                <div class="form-group" id="maxTimeGroup">
                    <label for="maxTime">Max Time (minutes, 0 = unlimited)</label>
                    <input type="number" id="maxTime" value="0" min="0" max="1440" step="1">
                </div>

                <div class="form-group">
                    <label for="logInterval">Log Interval (seconds)</label>
                    <input type="number" id="logInterval" value="1" min="0.5" max="60" step="0.5">
                </div>

                <div class="form-group">
                    <label for="testCycle">Test Cycle Profile</label>
                    <select id="testCycle" onchange="loadTestCycle()">
                        <option value="simple">Simple Discharge</option>
                        <option value="basic_capacity">Basic Capacity Test (1A, 2-4h)</option>
                        <option value="slow_capacity">Slow Capacity Test (0.5A, 5-8h)</option>
                        <option value="fast_screening">Fast Screening (2A, 1-2h)</option>
                        <option value="advanced_stress">Advanced Stress Test (6-8h)</option>
                        <option value="custom">Custom Cycle...</option>
                    </select>
                </div>

                <div id="cycleDetails" class="info-box" style="display: none;">
                    <strong>Cycle Details:</strong>
                    <div id="cycleDescription" style="margin: 10px 0; color: var(--color-text-dim);"></div>
                    <div id="cyclePhases"></div>
                    <button class="btn btn-primary" onclick="toggleCycleEditor()" style="margin-top: 10px; padding: 8px 16px; font-size: 0.9rem;">‚úèÔ∏è Edit Cycle</button>
                    <button id="deleteCycleBtn" class="btn btn-danger" onclick="deleteSelectedCycle()" style="margin-top: 10px; padding: 8px 16px; font-size: 0.9rem; display: none;">üóëÔ∏è Delete</button>
                </div>

                <div id="cycleEditor" style="display: none; margin-top: 15px; padding: 15px; background: var(--color-primary); border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; color: var(--color-success);">üîß Cycle Builder</h3>

                    <div class="form-group">
                        <label>Cycle Name</label>
                        <input type="text" id="customCycleName" placeholder="My Test Cycle" style="width: 100%;">
                    </div>

                    <div style="margin-bottom: 10px;">
                        <label style="display: block; margin-bottom: 8px;">Phases:</label>
                        <div id="phaseList" style="max-height: 300px; overflow-y: auto;"></div>
                    </div>

                    <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 15px;">
                        <button class="btn btn-primary" onclick="addPhase('discharge')" style="padding: 6px 12px; font-size: 0.85rem;">
                            ‚ûï Discharge
                        </button>
                        <button class="btn btn-primary" onclick="addPhase('rest')" style="padding: 6px 12px; font-size: 0.85rem;">
                            ‚ûï Rest
                        </button>
                        <button class="btn btn-primary" onclick="addPhase('ramp')" style="padding: 6px 12px; font-size: 0.85rem;">
                            ‚ûï Ramp
                        </button>
                    </div>

                    <div style="padding: 10px; background: rgba(0,0,0,0.2); border-radius: 6px; margin-bottom: 15px; font-size: 0.85rem;">
                        <strong>Quick Templates:</strong>
                        <div style="display: flex; gap: 6px; flex-wrap: wrap; margin-top: 8px;">
                            <button onclick="loadTemplate('simple')" style="padding: 4px 8px; background: var(--color-success); border: none; border-radius: 4px; color: var(--color-bg); cursor: pointer; font-size: 0.8rem;">Simple</button>
                            <button onclick="loadTemplate('with_rest')" style="padding: 4px 8px; background: var(--color-success); border: none; border-radius: 4px; color: var(--color-bg); cursor: pointer; font-size: 0.8rem;">With Rest</button>
                            <button onclick="loadTemplate('stress')" style="padding: 4px 8px; background: var(--color-success); border: none; border-radius: 4px; color: var(--color-bg); cursor: pointer; font-size: 0.8rem;">Stress Test</button>
                        </div>
                    </div>

                    <div class="btn-group" style="margin-top: 15px;">
                        <button class="btn btn-primary" onclick="applyCustomCycle()">‚úîÔ∏è Save & Apply</button>
                        <button class="btn btn-danger" onclick="cancelCycleEdit()">‚úñÔ∏è Cancel</button>
                    </div>
                </div>

                <div class="btn-group">
                    <button id="startBtn" class="btn btn-primary" onclick="startTest()">‚ñ∂ Start Test</button>
                    <button id="stopBtn" class="btn btn-danger" onclick="stopTest()" disabled>‚èπ Stop Test</button>
                </div>
            </div>

            <div class="card">
                <h2>üîß System Status</h2>
                <div class="system-status">
                    <div class="status-row">
                        <div class="status-indicator" id="connectionStatus">
                            <span class="indicator-dot" id="connectionDot"></span>
                            <span class="indicator-label">Device Connection</span>
                        </div>
                        <div class="status-value" id="connectionText">Checking...</div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator">
                            <span class="indicator-label">Serial Port</span>
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <select id="portSelect" style="flex: 1; padding: 6px; background: var(--color-primary); border: 1px solid var(--color-success); border-radius: 4px; color: var(--color-text); font-size: 0.9rem;">
                                <option value="">Loading...</option>
                            </select>
                            <button onclick="refreshPorts()" style="padding: 6px 12px; background: var(--color-success); border: none; border-radius: 4px; color: var(--color-bg); cursor: pointer; font-size: 0.85rem; font-weight: 600;">üîÑ</button>
                            <button onclick="connectToPort()" style="padding: 6px 12px; background: var(--color-primary); border: 2px solid var(--color-success); border-radius: 4px; color: var(--color-text); cursor: pointer; font-size: 0.85rem; font-weight: 600;">Connect</button>
                        </div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator">
                            <span class="indicator-label">Reconnect</span>
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <button id="reconnectBtn" onclick="reconnectDevice()" style="padding: 6px 12px; background: var(--color-accent); border: none; border-radius: 4px; color: white; cursor: pointer; font-size: 0.85rem; font-weight: 600; display: none;">Reconnect</button>
                        </div>
                    </div>
                    <div class="status-row" id="connectionHealthRow" style="display: none;">
                        <div class="status-indicator">
                            <span class="indicator-label">Connection Health</span>
                        </div>
                        <div class="status-value" id="connectionHealthText" style="font-size: 0.8rem;">OK</div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator" id="loadStatus">
                            <span class="indicator-dot" id="loadDot"></span>
                            <span class="indicator-label">Load Status</span>
                        </div>
                        <div class="status-value" id="loadText">OFF</div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator" id="testStatus">
                            <span class="indicator-dot" id="testDot"></span>
                            <span class="indicator-label">Test Status</span>
                        </div>
                        <div class="status-value" id="testStatusText">Idle</div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator">
                            <span class="indicator-label">Set Current</span>
                        </div>
                        <div class="status-value" id="setCurrentText">0.00 A</div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator">
                            <span class="indicator-label">Cutoff Voltage</span>
                        </div>
                        <div class="status-value" id="cutoffText">0.00 V</div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator">
                            <span class="indicator-label">Last Update</span>
                        </div>
                        <div class="status-value" id="lastUpdateText">Never</div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator">
                            <span class="indicator-label">System Time</span>
                        </div>
                        <div class="status-value" id="systemTimeText" style="font-family: monospace;">--:--:--</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üìä Live Data</h2>
                
                <div class="status-display">
                    <div class="status-item">
                        <div class="status-label">Voltage</div>
                        <div class="status-value" id="voltage">0.00<span class="status-unit">V</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Current</div>
                        <div class="status-value" id="current">0.00<span class="status-unit">A</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Power</div>
                        <div class="status-value" id="power">0.00<span class="status-unit">W</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Resistance</div>
                        <div class="status-value" id="resistance">0.00<span class="status-unit">Œ©</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Capacity</div>
                        <div class="status-value" id="capacity">0<span class="status-unit">mAh</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Energy</div>
                        <div class="status-value" id="energy">0<span class="status-unit">mWh</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Temperature</div>
                        <div class="status-value" id="temperature">0<span class="status-unit">¬∞C</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Runtime</div>
                        <div class="status-value" id="runtime">00:00:00</div>
                    </div>
                </div>

                <div class="progress-bar" data-progress="0.00%">
                    <div class="progress-fill" id="progressBar"></div>
                </div>

                <!-- Device Status Info -->
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 15px; font-size: 12px;">
                    <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                        <div style="color: #aaa; font-size: 10px;">Set Current</div>
                        <div id="setCurrentDisplay" style="font-weight: bold; color: #44ff44;">1.00A</div>
                    </div>
                    <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                        <div style="color: #aaa; font-size: 10px;">Load Status</div>
                        <div id="loadStatusDisplay" style="font-weight: bold; color: #ff4444;">OFF</div>
                    </div>
                    <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                        <div style="color: #aaa; font-size: 10px;">Cutoff Voltage</div>
                        <div id="cutoffDisplay" style="font-weight: bold;">3.00V</div>
                    </div>
                </div>

                <div class="warning-box" id="statusMessage">
                    ‚ö†Ô∏è Ready for test. Connect 18650 battery and verify parameters.
                </div>

                <!-- Load Struggle Warning -->
                <div class="warning-box" id="loadStruggleWarning" style="display: none; background: linear-gradient(45deg, #ff4444, #ff8800); border: 2px solid #ffaa00; animation: warning-pulse 1s infinite;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <span style="font-size: 24px;">‚ö†Ô∏è</span>
                        <div>
                            <strong>LOAD STRUGGLE DETECTED!</strong><br>
                            <span id="loadStruggleText">Current dropping significantly - Check battery connections!</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>üìà Discharge Curve</h2>

            <!-- Plot Selection Controls -->
            <div style="background: rgba(0,217,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                <div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">
                    <div style="font-weight: bold; color: #00d9ff;">Plot Values:</div>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotVoltage" checked onchange="updateChartOptions()">
                        <span>‚ö° Voltage</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotCurrent" checked onchange="updateChartOptions()">
                        <span>üîã Current</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotPower" onchange="updateChartOptions()">
                        <span>‚ö° Power</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotResistance" onchange="updateChartOptions()">
                        <span>Œ© Resistance</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotCapacity" checked onchange="updateChartOptions()">
                        <span>üîã Capacity</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotEnergy" onchange="updateChartOptions()">
                        <span>‚ö° Energy</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotTemperature" onchange="updateChartOptions()">
                        <span>üå° Temperature</span>
                    </label>
                </div>
            </div>

            <div class="chart-container">
                <div id="chart" style="width:100%;height:400px;"></div>
            </div>
        </div>

        <div class="card">
            <h2>üìù Test Log</h2>
            <div id="log"></div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="exportData()">üíæ Export Measure File (CSV)</button>
                <button class="btn btn-primary" onclick="clearLog()">üóëÔ∏è Clear Log</button>
            </div>
        </div>

        <div class="card" id="analysisCard" style="display: none;">
            <h2>üìä Testergebnis-Auswertung</h2>
            <div id="analysisResults" style="line-height: 1.8;"></div>
            <div style="margin-top: 15px; padding: 10px; background: rgba(255,165,0,0.1); border-left: 3px solid #ffa500; font-size: 0.85rem;">
                <strong>‚ö†Ô∏è Hinweis:</strong> Diese Auswertung dient nur als Orientierung. Die Bewertung basiert auf typischen 18650-Zellenwerten und kann je nach Hersteller, Alter und Zustand der Zelle variieren. F√ºr kritische Anwendungen sollten professionelle Testger√§te und Herstellerspezifikationen herangezogen werden.
            </div>
        </div>
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        // Backend API URL - use same host as page was loaded from
        const API_BASE = `${window.location.protocol}//${window.location.hostname}:5000/api`;
        const SIMULATION_MODE = true;  // Set to true for demo without hardware

        let testRunning = false;
        let testStartTime = null;
        let testInterval = null;
        let statusInterval = null;
        let dataPoints = [];
        let chart = null;
        let socket = null;  // WebSocket connection

        // Load struggle detection
        let currentHistory = [];
        let expectedCurrent = 0;
        let loadStruggleDetected = false;

        // Chart plotting options
        let plotOptions = {
            voltage: true,
            current: true,
            power: false,
            resistance: false,
            capacity: true,
            energy: false,
            temperature: false
        };

        // 18650 Battery presets
        const presets = {
            '18650_0.5A': { type: 'liion', current: 0.5, cutoff: 2.5 },
            '18650_1.0A': { type: 'liion', current: 1.0, cutoff: 2.5 },
            '18650_2.0A': { type: 'liion', current: 2.0, cutoff: 2.5 }
        };

        // Test cycle definitions with phases
        const testCycles = {
            'simple': {
                name: 'Simple Discharge',
                description: 'Single constant-current discharge',
                phases: [
                    { name: 'Discharge', type: 'discharge', current: 1.0, cutoff: 2.5, maxTime: 0 }
                ]
            },
            'basic_capacity': {
                name: 'Basic Capacity Test',
                description: 'Standard 1A discharge for capacity verification (2-4h)',
                phases: [
                    { name: 'Initial Rest', type: 'rest', duration: 60 },
                    { name: 'Discharge', type: 'discharge', current: 1.0, cutoff: 2.5, maxTime: 240 }
                ]
            },
            'slow_capacity': {
                name: 'Slow Capacity Test',
                description: 'Low-rate 0.5A discharge for accurate capacity (5-8h)',
                phases: [
                    { name: 'Extended Rest', type: 'rest', duration: 120 },
                    { name: 'Slow Discharge', type: 'discharge', current: 0.5, cutoff: 2.5, maxTime: 480 }
                ]
            },
            'fast_screening': {
                name: 'Fast Screening',
                description: 'High-rate 2A discharge for quick screening (1-2h)',
                phases: [
                    { name: 'Brief Rest', type: 'rest', duration: 30 },
                    { name: 'Fast Discharge', type: 'discharge', current: 2.0, cutoff: 2.5, maxTime: 120 }
                ]
            },
            'advanced_stress': {
                name: 'Advanced Stress Test',
                description: 'Multi-phase dynamic load testing (6-8h)',
                phases: [
                    { name: 'Initial Rest', type: 'rest', duration: 60 },
                    { name: 'Conditioning', type: 'discharge', current: 1.0, duration: 900 },
                    { name: 'Ramp Up', type: 'ramp', startCurrent: 1.0, endCurrent: 2.0, duration: 900 },
                    { name: 'Max Load', type: 'discharge', current: 2.0, duration: 900 },
                    { name: 'Ramp Down', type: 'ramp', startCurrent: 2.0, endCurrent: 1.0, duration: 900 },
                    { name: 'Final Discharge', type: 'discharge', current: 1.0, cutoff: 2.5, maxTime: 360 }
                ]
            },
            'custom': {
                name: 'Custom Cycle',
                description: 'User-defined test cycle',
                phases: [
                    { name: 'Discharge', type: 'discharge', current: 1.0, cutoff: 2.5, maxTime: 0 }
                ]
            }
        };

        let currentCycle = null;
        let customCycle = null;

        // Initialize Plotly chart
        function initChart() {
            const layout = {
                paper_bgcolor: '#1a1a2e',
                plot_bgcolor: '#1a1a2e',
                font: { color: '#eaeaea', family: 'monospace' },
                margin: { l: 60, r: 60, t: 30, b: 50 },
                xaxis: {
                    title: 'Zeit (s)',
                    gridcolor: 'rgba(0, 217, 255, 0.1)',
                    linecolor: 'rgba(0, 217, 255, 0.5)',
                    zerolinecolor: 'rgba(0, 217, 255, 0.3)'
                },
                yaxis: {
                    title: 'Spannung (V)',
                    gridcolor: 'rgba(0, 217, 255, 0.1)',
                    linecolor: 'rgba(0, 217, 255, 0.5)',
                    zerolinecolor: 'rgba(0, 217, 255, 0.3)'
                },
                yaxis2: {
                    title: 'Strom (A) / Leistung (W)',
                    overlaying: 'y',
                    side: 'right',
                    gridcolor: 'rgba(0, 217, 255, 0.05)'
                },
                showlegend: true,
                legend: { x: 0.01, y: 0.99, bgcolor: 'rgba(26, 26, 46, 0.8)' }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['lasso2d', 'select2d']
            };

            // Create empty traces for all metrics
            const traces = [
                { x: [], y: [], name: 'Spannung', line: { color: '#3498db', width: 2 }, yaxis: 'y' },
                { x: [], y: [], name: 'Strom', line: { color: '#e74c3c', width: 2 }, yaxis: 'y2' },
                { x: [], y: [], name: 'Leistung', line: { color: '#f39c12', width: 2 }, yaxis: 'y2', visible: 'legendonly' },
                { x: [], y: [], name: 'Widerstand', line: { color: '#9b59b6', width: 2 }, yaxis: 'y2', visible: 'legendonly' },
                { x: [], y: [], name: 'Kapazit√§t', line: { color: '#2ecc71', width: 2 }, yaxis: 'y2', visible: 'legendonly' },
                { x: [], y: [], name: 'Energie', line: { color: '#e67e22', width: 2 }, yaxis: 'y2', visible: 'legendonly' },
                { x: [], y: [], name: 'Temperatur', line: { color: '#1abc9c', width: 2 }, yaxis: 'y2', visible: 'legendonly' }
            ];

            Plotly.newPlot('chart', traces, layout, config);

            chart = {
                data: [],
                draw: function() {
                    if (this.data.length === 0) return;

                    const times = this.data.map(d => d.time);
                    const voltages = this.data.map(d => d.voltage);
                    const currents = this.data.map(d => d.current);
                    const powers = this.data.map(d => d.power);
                    const resistances = this.data.map(d => d.resistance || 0);
                    const capacities = this.data.map(d => d.capacity / 1000); // Convert to Ah
                    const energies = this.data.map(d => d.energy / 1000); // Convert to Wh
                    const temperatures = this.data.map(d => d.temperature || 0);

                    const update = {
                        x: [times, times, times, times, times, times, times],
                        y: [voltages, currents, powers, resistances, capacities, energies, temperatures]
                    };

                    Plotly.update('chart', update, {}, [0, 1, 2, 3, 4, 5, 6]);

                    // Update trace visibility based on plotOptions checkboxes
                    const visibility = [
                        plotOptions.voltage ? true : 'legendonly',
                        plotOptions.current ? true : 'legendonly',
                        plotOptions.power ? true : 'legendonly',
                        plotOptions.resistance ? true : 'legendonly',
                        plotOptions.capacity ? true : 'legendonly',
                        plotOptions.energy ? true : 'legendonly',
                        plotOptions.temperature ? true : 'legendonly'
                    ];
                    Plotly.restyle('chart', {visible: visibility});
                }
            };
        }

        function setPreset(presetName) {
            const preset = presets[presetName];
            if (preset) {
                document.getElementById('batteryType').value = preset.type;
                document.getElementById('dischargeCurrent').value = preset.current;
                document.getElementById('cutoffVoltage').value = preset.cutoff;
                document.getElementById('testCycle').value = 'simple';
                log(`Preset "${presetName}" loaded`, 'info');
            }
        }

        function loadTestCycle() {
            const cycleId = document.getElementById('testCycle').value;
            let cycle = testCycles[cycleId];

            if (cycleId === 'custom' && customCycle) {
                cycle = customCycle;
            } else if (cycleId.startsWith('saved_')) {
                // Load saved custom cycle
                const savedCycle = savedCustomCycles.find(c => c.id === cycleId);
                if (savedCycle) {
                    cycle = savedCycle;
                    customCycle = savedCycle; // Also set as current custom cycle
                }
            }

            if (cycle) {
                currentCycle = cycle;

                // Set parameters from first discharge phase
                const dischargePhase = cycle.phases.find(p => p.type === 'discharge');
                if (dischargePhase) {
                    document.getElementById('dischargeCurrent').value = dischargePhase.current || 1.0;
                    document.getElementById('cutoffVoltage').value = dischargePhase.cutoff || 2.5;
                    // maxTime is already in minutes
                    document.getElementById('maxTime').value = dischargePhase.maxTime || 0;
                }

                // Show/hide maxTime field based on cycle complexity
                // Simple cycles (1 phase, no ramps) show maxTime, complex cycles hide it
                const isSimpleCycle = cycle.phases.length === 1 &&
                    !cycle.phases.some(p => p.type === 'ramp' || p.type === 'rest');
                const maxTimeGroup = document.getElementById('maxTimeGroup');
                if (maxTimeGroup) {
                    maxTimeGroup.style.display = isSimpleCycle ? 'block' : 'none';
                }

                // Show cycle details
                displayCycleDetails(cycle);

                log(`Test cycle loaded: ${cycle.name}`, 'info');
                log(`Description: ${cycle.description}`, 'info');
                log(`Phases: ${cycle.phases.length}`, 'info');

                // Update status message
                const statusMsg = document.getElementById('statusMessage');
                if (statusMsg) {
                    statusMsg.textContent = `üìã ${cycle.name} - ${cycle.description}`;
                    statusMsg.className = 'info-box';
                }

                // Show edit button for custom
                if (cycleId === 'custom' || cycleId.startsWith('saved_') || cycle.phases.length > 1) {
                    document.getElementById('cycleDetails').style.display = 'block';
                } else {
                    document.getElementById('cycleDetails').style.display = 'none';
                }

                // Show delete button only for saved cycles
                const deleteBtn = document.getElementById('deleteCycleBtn');
                if (deleteBtn) {
                    deleteBtn.style.display = cycleId.startsWith('saved_') ? 'inline-block' : 'none';
                }
            }
        }

        function displayCycleDetails(cycle) {
            const detailsDiv = document.getElementById('cycleDescription');
            const phasesDiv = document.getElementById('cyclePhases');

            detailsDiv.textContent = cycle.description;

            // Display phases
            let phasesHTML = '<div style="margin-top: 10px;">';
            cycle.phases.forEach((phase, index) => {
                phasesHTML += `<div class="phase-item">`;
                phasesHTML += `<div class="phase-header">Phase ${index + 1}: ${phase.name}</div>`;
                phasesHTML += `<div class="phase-details">`;

                if (phase.type === 'rest') {
                    phasesHTML += `<span class="cycle-param">‚è∏Ô∏è Rest: ${phase.duration}s</span>`;
                } else if (phase.type === 'discharge') {
                    phasesHTML += `<span class="cycle-param">‚ö° ${phase.current}A</span>`;
                    if (phase.cutoff) phasesHTML += `<span class="cycle-param">üìâ Cutoff: ${phase.cutoff}V</span>`;
                    if (phase.duration) phasesHTML += `<span class="cycle-param">‚è±Ô∏è ${Math.floor(phase.duration/60)}min</span>`;
                    if (phase.maxTime) phasesHTML += `<span class="cycle-param">‚è±Ô∏è Max: ${Math.floor(phase.maxTime/60)}min</span>`;
                } else if (phase.type === 'ramp') {
                    phasesHTML += `<span class="cycle-param">üìà ${phase.startCurrent}A ‚Üí ${phase.endCurrent}A</span>`;
                    phasesHTML += `<span class="cycle-param">‚è±Ô∏è ${Math.floor(phase.duration/60)}min</span>`;
                }

                phasesHTML += `</div></div>`;
            });
            phasesHTML += '</div>';

            phasesDiv.innerHTML = phasesHTML;
        }

        // Cycle Builder state
        let customPhases = [];

        function toggleCycleEditor() {
            const editor = document.getElementById('cycleEditor');
            const isHidden = editor.style.display === 'none';

            if (isHidden) {
                // Load current cycle into editor
                if (currentCycle && currentCycle.phases) {
                    document.getElementById('customCycleName').value = currentCycle.name;
                    customPhases = JSON.parse(JSON.stringify(currentCycle.phases)); // Deep copy
                } else {
                    customPhases = [];
                }
                renderPhaseList();
                editor.style.display = 'block';
            } else {
                editor.style.display = 'none';
            }
        }

        function addPhase(type) {
            let newPhase;
            if (type === 'discharge') {
                newPhase = {
                    name: `Discharge ${customPhases.length + 1}`,
                    type: 'discharge',
                    current: 1.0,
                    cutoff: 2.5,
                    maxTime: 0
                };
            } else if (type === 'rest') {
                newPhase = {
                    name: `Rest ${customPhases.length + 1}`,
                    type: 'rest',
                    duration: 60
                };
            } else if (type === 'ramp') {
                newPhase = {
                    name: `Ramp ${customPhases.length + 1}`,
                    type: 'ramp',
                    startCurrent: 1.0,
                    endCurrent: 2.0,
                    duration: 900
                };
            }
            customPhases.push(newPhase);
            renderPhaseList();
        }

        function removePhase(index) {
            customPhases.splice(index, 1);
            renderPhaseList();
        }

        function movePhaseUp(index) {
            if (index > 0) {
                [customPhases[index - 1], customPhases[index]] = [customPhases[index], customPhases[index - 1]];
                renderPhaseList();
            }
        }

        function movePhaseDown(index) {
            if (index < customPhases.length - 1) {
                [customPhases[index], customPhases[index + 1]] = [customPhases[index + 1], customPhases[index]];
                renderPhaseList();
            }
        }

        function updatePhaseValue(index, field, value) {
            if (field === 'duration' || field === 'maxTime') {
                customPhases[index][field] = parseFloat(value) * 60; // Convert minutes to seconds
            } else if (field === 'current' || field === 'cutoff' || field === 'startCurrent' || field === 'endCurrent') {
                customPhases[index][field] = parseFloat(value);
            } else {
                customPhases[index][field] = value;
            }
        }

        function renderPhaseList() {
            const listDiv = document.getElementById('phaseList');

            if (customPhases.length === 0) {
                listDiv.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">No phases defined. Add a phase above.</div>';
                return;
            }

            let html = '';
            customPhases.forEach((phase, index) => {
                html += `<div class="phase-item" style="margin: 8px 0; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 6px; border-left: 3px solid ${phase.type === 'discharge' ? 'var(--color-success)' : phase.type === 'rest' ? 'var(--color-accent)' : '#ff9800'};">`;

                // Header with controls
                html += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">`;
                html += `<input type="text" value="${phase.name}" onchange="updatePhaseValue(${index}, 'name', this.value)" style="flex: 1; background: transparent; border: none; border-bottom: 1px solid var(--color-success); color: var(--color-text); font-weight: bold; padding: 2px;">`;
                html += `<div style="display: flex; gap: 4px; margin-left: 8px;">`;
                html += `<button onclick="movePhaseUp(${index})" style="padding: 2px 6px; background: var(--color-primary); border: 1px solid #555; border-radius: 3px; color: var(--color-text); cursor: pointer;" ${index === 0 ? 'disabled' : ''}>‚ñ≤</button>`;
                html += `<button onclick="movePhaseDown(${index})" style="padding: 2px 6px; background: var(--color-primary); border: 1px solid #555; border-radius: 3px; color: var(--color-text); cursor: pointer;" ${index === customPhases.length - 1 ? 'disabled' : ''}>‚ñº</button>`;
                html += `<button onclick="removePhase(${index})" style="padding: 2px 6px; background: var(--color-danger); border: none; border-radius: 3px; color: white; cursor: pointer;">‚úï</button>`;
                html += `</div></div>`;

                // Phase-specific fields
                if (phase.type === 'discharge') {
                    html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.85rem;">`;
                    html += `<div><label style="display: block; font-size: 0.75rem; color: #888;">Current (A)</label>`;
                    html += `<input type="number" value="${phase.current}" step="0.1" min="0.1" max="20" onchange="updatePhaseValue(${index}, 'current', this.value)" style="width: 100%; padding: 4px; background: var(--color-primary); border: 1px solid #555; border-radius: 3px; color: var(--color-text);"></div>`;
                    html += `<div><label style="display: block; font-size: 0.75rem; color: #888;">Cutoff (V)</label>`;
                    html += `<input type="number" value="${phase.cutoff || 2.5}" step="0.1" min="2.0" max="4.2" onchange="updatePhaseValue(${index}, 'cutoff', this.value)" style="width: 100%; padding: 4px; background: var(--color-primary); border: 1px solid #555; border-radius: 3px; color: var(--color-text);"></div>`;
                    html += `<div style="grid-column: span 2;"><label style="display: block; font-size: 0.75rem; color: #888;">Max Duration (min, 0=until cutoff)</label>`;
                    html += `<input type="number" value="${(phase.maxTime || 0) / 60}" min="0" max="480" onchange="updatePhaseValue(${index}, 'maxTime', this.value)" style="width: 100%; padding: 4px; background: var(--color-primary); border: 1px solid #555; border-radius: 3px; color: var(--color-text);"></div>`;
                    html += `</div>`;
                } else if (phase.type === 'rest') {
                    html += `<div style="font-size: 0.85rem;">`;
                    html += `<label style="display: block; font-size: 0.75rem; color: #888;">Rest Duration (sec)</label>`;
                    html += `<input type="number" value="${phase.duration}" min="1" max="3600" onchange="customPhases[${index}].duration = parseInt(this.value)" style="width: 100%; padding: 4px; background: var(--color-primary); border: 1px solid #555; border-radius: 3px; color: var(--color-text);">`;
                    html += `</div>`;
                } else if (phase.type === 'ramp') {
                    html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.85rem;">`;
                    html += `<div><label style="display: block; font-size: 0.75rem; color: #888;">Start (A)</label>`;
                    html += `<input type="number" value="${phase.startCurrent}" step="0.1" min="0.1" max="20" onchange="updatePhaseValue(${index}, 'startCurrent', this.value)" style="width: 100%; padding: 4px; background: var(--color-primary); border: 1px solid #555; border-radius: 3px; color: var(--color-text);"></div>`;
                    html += `<div><label style="display: block; font-size: 0.75rem; color: #888;">End (A)</label>`;
                    html += `<input type="number" value="${phase.endCurrent}" step="0.1" min="0.1" max="20" onchange="updatePhaseValue(${index}, 'endCurrent', this.value)" style="width: 100%; padding: 4px; background: var(--color-primary); border: 1px solid #555; border-radius: 3px; color: var(--color-text);"></div>`;
                    html += `<div style="grid-column: span 2;"><label style="display: block; font-size: 0.75rem; color: #888;">Ramp Duration (min)</label>`;
                    html += `<input type="number" value="${(phase.duration || 900) / 60}" min="1" max="60" onchange="updatePhaseValue(${index}, 'duration', this.value)" style="width: 100%; padding: 4px; background: var(--color-primary); border: 1px solid #555; border-radius: 3px; color: var(--color-text);"></div>`;
                    html += `</div>`;
                }

                html += `</div>`;
            });

            listDiv.innerHTML = html;
        }

        function loadTemplate(template) {
            if (template === 'simple') {
                customPhases = [{
                    name: 'Standard Discharge',
                    type: 'discharge',
                    current: 1.0,
                    cutoff: 2.5,
                    maxTime: 0
                }];
            } else if (template === 'with_rest') {
                customPhases = [
                    { name: 'Discharge 1', type: 'discharge', current: 1.0, cutoff: 3.0, maxTime: 0 },
                    { name: 'Rest', type: 'rest', duration: 60 },
                    { name: 'Discharge 2', type: 'discharge', current: 0.5, cutoff: 2.5, maxTime: 0 }
                ];
            } else if (template === 'stress') {
                customPhases = [
                    { name: 'High Load', type: 'discharge', current: 2.0, cutoff: 3.5, maxTime: 300 },
                    { name: 'Rest', type: 'rest', duration: 30 },
                    { name: 'Low Load', type: 'discharge', current: 0.5, cutoff: 3.0, maxTime: 300 },
                    { name: 'Ramp', type: 'ramp', startCurrent: 0.5, endCurrent: 2.0, duration: 600 },
                    { name: 'Final Discharge', type: 'discharge', current: 1.0, cutoff: 2.5, maxTime: 0 }
                ];
            }
            renderPhaseList();
        }

        // Storage for saved custom cycles
        let savedCustomCycles = JSON.parse(localStorage.getItem('savedCustomCycles') || '[]');

        function applyCustomCycle() {
            const cycleName = document.getElementById('customCycleName').value || 'Custom Cycle';

            if (customPhases.length === 0) {
                log('‚ö†Ô∏è No phases defined!', 'warning');
                return;
            }

            customCycle = {
                name: cycleName,
                description: `Custom ${customPhases.length}-phase test cycle`,
                phases: JSON.parse(JSON.stringify(customPhases)) // Deep copy
            };

            // Save to localStorage and add to dropdown
            const cycleId = 'saved_' + Date.now();
            const savedCycle = { id: cycleId, ...customCycle };

            // Check if cycle with same name exists, replace it
            const existingIndex = savedCustomCycles.findIndex(c => c.name === cycleName);
            if (existingIndex >= 0) {
                savedCustomCycles[existingIndex] = savedCycle;
            } else {
                savedCustomCycles.push(savedCycle);
            }
            localStorage.setItem('savedCustomCycles', JSON.stringify(savedCustomCycles));

            // Update dropdown
            updateCycleDropdown();

            // Select the new cycle
            document.getElementById('testCycle').value = cycleId;
            loadTestCycle();

            // Hide editor
            document.getElementById('cycleEditor').style.display = 'none';

            log(`Custom cycle saved: ${cycleName} with ${customPhases.length} phases`, 'info');
        }

        function updateCycleDropdown() {
            const select = document.getElementById('testCycle');

            // Remove old saved cycles from dropdown
            const toRemove = [];
            for (let i = 0; i < select.options.length; i++) {
                if (select.options[i].value.startsWith('saved_')) {
                    toRemove.push(select.options[i]);
                }
            }
            toRemove.forEach(opt => opt.remove());

            // Add saved cycles
            savedCustomCycles.forEach(cycle => {
                const option = document.createElement('option');
                option.value = cycle.id;
                option.textContent = `üìÅ ${cycle.name}`;
                select.appendChild(option);
            });
        }

        function deleteSavedCycle(cycleId) {
            savedCustomCycles = savedCustomCycles.filter(c => c.id !== cycleId);
            localStorage.setItem('savedCustomCycles', JSON.stringify(savedCustomCycles));
            updateCycleDropdown();
            log('Custom cycle deleted', 'info');
        }

        function deleteSelectedCycle() {
            const cycleId = document.getElementById('testCycle').value;
            if (cycleId.startsWith('saved_')) {
                const cycle = savedCustomCycles.find(c => c.id === cycleId);
                if (cycle && confirm(`Delete cycle "${cycle.name}"?`)) {
                    deleteSavedCycle(cycleId);
                    // Select first cycle
                    document.getElementById('testCycle').value = 'simple';
                    loadTestCycle();
                }
            }
        }

        function cancelCycleEdit() {
            document.getElementById('cycleEditor').style.display = 'none';
        }

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            const timestamp = new Date().toLocaleTimeString('de-DE');
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            log('Log cleared', 'info');
        }

        async function startTest() {
            if (testRunning) {
                log('‚ö†Ô∏è Test already running - cannot start new test', 'warning');
                return;
            }

            // Double-check device status before starting
            try {
                const statusResponse = await fetch(`${API_BASE}/status`);
                const statusResult = await statusResponse.json();

                if (statusResult.load_on && statusResult.data && statusResult.data.current > 0.01) {
                    log('‚ùå Cannot start test - device is already discharging', 'error');
                    log('   Please stop the current test first', 'warning');
                    return;
                }
            } catch (error) {
                log('‚ö†Ô∏è Could not verify device status - proceeding anyway', 'warning');
            }

            const current = parseFloat(document.getElementById('dischargeCurrent').value);
            const cutoff = parseFloat(document.getElementById('cutoffVoltage').value);
            const maxTime = parseInt(document.getElementById('maxTime').value) * 60;
            const logInterval = parseInt(document.getElementById('logInterval').value) * 1000;

            if (!SIMULATION_MODE) {
                // Real hardware mode
                try {
                    const response = await fetch(`${API_BASE}/start`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            current: current,
                            cutoff: cutoff,
                            maxTime: maxTime
                        })
                    });

                    const result = await response.json();

                    if (!result.success) {
                        log(`Fehler beim Start: ${result.error}`, 'error');
                        return;
                    }

                    testRunning = true;
                    testStartTime = Date.now();
                    dataPoints = [];

                    // Instant button update
                    updateButtonStatesInstant(true);
                    document.getElementById('statusMessage').textContent = 'üîã Test running...';
                    document.getElementById('statusMessage').className = 'info-box';

                    // Enhanced logging with device communication details
                    log(`üöÄ Starting Battery Test...`, 'success');
                    log(`‚öôÔ∏è Parameters: ${current}A, Cutoff: ${cutoff}V, Max Time: ${maxTime}s`, 'info');
                    log(`üì° Sending device configuration commands...`, 'info');
                    log(`‚úì ${result.message}`, 'success');
                    log(`‚è±Ô∏è Test monitoring started`, 'info');

                    // Start polling for status updates
                    statusInterval = setInterval(updateStatus, logInterval);

                } catch (error) {
                    log(`Connection error: ${error.message}`, 'error');
                    log('Is dl24_webserver.py running?', 'warning');
                }

            } else if (SIMULATION_MODE) {
                // Simulation f√ºr Demo
                let simVoltage = 4.2;
                let simCapacity = 0;
                
                testInterval = setInterval(() => {
                    const runtime = (Date.now() - testStartTime) / 1000;
                    
                    // Simulate voltage drop
                    simVoltage -= 0.002;
                    simCapacity += (current / 3600) * (logInterval / 1000) * 1000;
                    
                    const power = simVoltage * current;
                    const resistance = (current > 0.001) ? (simVoltage / current) : 0.0;
                    const energy = (simCapacity * simVoltage) / 1000;

                    updateDisplay(simVoltage, current, power, resistance, simCapacity, energy, 25.0, runtime);
                    dataPoints.push({ time: runtime, voltage: simVoltage, current: current, power: power, resistance: resistance, capacity: simCapacity, energy: energy, temperature: 25.0 });
                    
                    if (chart) {
                        chart.data = dataPoints;
                        chart.draw();
                    }
                    
                    // Check cutoff
                    if (simVoltage <= cutoff || (maxTime > 0 && runtime >= maxTime)) {
                        stopTest();
                    }
                }, logInterval);
            } else {
                // Real implementation mit dl24.py
                log('‚ö†Ô∏è Echte Hardware-Kommunikation nicht implementiert in dieser Demo', 'warning');
                log('Bitte dl24.py Backend-Server starten f√ºr echte Tests', 'warning');
            }
        }

        async function stopTest() {
            if (!testRunning) return;

            // Enhanced logging for test stopping
            log(`‚èπÔ∏è Stopping Battery Test...`, 'warning');

            if (!SIMULATION_MODE) {
                // Real hardware mode
                try {
                    log(`üì° Reading final measurements...`, 'info');
                    const response = await fetch(`${API_BASE}/stop`, {
                        method: 'POST'
                    });

                    const result = await response.json();

                    if (result.success) {
                        log(`‚úì ${result.message}`, 'success');
                        log(`‚èπÔ∏è Test monitoring stopped`, 'info');
                    } else {
                        log(`‚úó Error stopping: ${result.error}`, 'error');
                    }
                } catch (error) {
                    log(`‚úó Connection error: ${error.message}`, 'error');
                }

                clearInterval(statusInterval);
            } else {
                clearInterval(testInterval);
                log(`‚úì Simulation stopped`, 'info');
            }

            testRunning = false;

            // Reset load struggle detection
            loadStruggleDetected = false;
            currentHistory = [];
            expectedCurrent = 0;
            hideLoadStruggleWarning();

            // Instant button update
            updateButtonStatesInstant(false);
            document.getElementById('statusMessage').textContent = 'üõë Test completed';
            document.getElementById('statusMessage').className = 'warning-box';

            const capacity = parseFloat(document.getElementById('capacity').textContent);
            const energy = parseFloat(document.getElementById('energy').textContent);

            log(`Test completed - Capacity: ${capacity}mAh, Energy: ${energy}mWh`, 'info');

            // Run analysis after test completion
            analyzeResults();
        }

        function analyzeResults() {
            if (dataPoints.length < 10) {
                return; // Not enough data for analysis
            }

            const analysisCard = document.getElementById('analysisCard');
            const resultsDiv = document.getElementById('analysisResults');

            // Get test data
            const capacity = dataPoints[dataPoints.length - 1].capacity || 0;
            const energy = dataPoints[dataPoints.length - 1].energy || 0;
            const runtime = dataPoints[dataPoints.length - 1].time || 0;
            const startVoltage = dataPoints[0].voltage;
            const endVoltage = dataPoints[dataPoints.length - 1].voltage;
            const avgCurrent = dataPoints.reduce((sum, p) => sum + p.current, 0) / dataPoints.length;

            // Calculate average resistance (excluding first few points for stabilization)
            const resistancePoints = dataPoints.slice(5).filter(p => p.resistance && p.resistance > 0 && p.resistance < 1);
            const avgResistance = resistancePoints.length > 0
                ? resistancePoints.reduce((sum, p) => sum + p.resistance, 0) / resistancePoints.length
                : 0;

            // Calculate voltage drop rate
            const voltageDrop = startVoltage - endVoltage;
            const voltageDropRate = runtime > 0 ? (voltageDrop / runtime) * 3600 : 0; // V/h

            // Rating functions
            function rateCapacity(cap) {
                if (cap >= 3000) return { rating: 'Ausgezeichnet', color: '#00ff00', score: 5 };
                if (cap >= 2500) return { rating: 'Sehr gut', color: '#88ff00', score: 4 };
                if (cap >= 2000) return { rating: 'Gut', color: '#ffff00', score: 3 };
                if (cap >= 1500) return { rating: 'Akzeptabel', color: '#ffaa00', score: 2 };
                if (cap >= 1000) return { rating: 'Schwach', color: '#ff6600', score: 1 };
                return { rating: 'Schlecht', color: '#ff0000', score: 0 };
            }

            function rateResistance(res) {
                if (res <= 0) return { rating: 'N/A', color: '#888888', score: -1 };
                if (res <= 0.030) return { rating: 'Ausgezeichnet', color: '#00ff00', score: 5 };
                if (res <= 0.050) return { rating: 'Sehr gut', color: '#88ff00', score: 4 };
                if (res <= 0.080) return { rating: 'Gut', color: '#ffff00', score: 3 };
                if (res <= 0.120) return { rating: 'Akzeptabel', color: '#ffaa00', score: 2 };
                if (res <= 0.200) return { rating: 'Erh√∂ht', color: '#ff6600', score: 1 };
                return { rating: 'Hoch', color: '#ff0000', score: 0 };
            }

            function rateVoltageStability(dropRate) {
                if (dropRate <= 0.3) return { rating: 'Sehr stabil', color: '#00ff00', score: 5 };
                if (dropRate <= 0.5) return { rating: 'Stabil', color: '#88ff00', score: 4 };
                if (dropRate <= 0.8) return { rating: 'Normal', color: '#ffff00', score: 3 };
                if (dropRate <= 1.2) return { rating: 'Erh√∂ht', color: '#ffaa00', score: 2 };
                return { rating: 'Instabil', color: '#ff6600', score: 1 };
            }

            const capRating = rateCapacity(capacity);
            const resRating = rateResistance(avgResistance);
            const voltRating = rateVoltageStability(voltageDropRate);

            // Overall rating
            const scores = [capRating.score, voltRating.score];
            if (resRating.score >= 0) scores.push(resRating.score);
            const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;

            let overallRating, overallColor;
            if (avgScore >= 4.5) { overallRating = 'Ausgezeichnet'; overallColor = '#00ff00'; }
            else if (avgScore >= 3.5) { overallRating = 'Sehr gut'; overallColor = '#88ff00'; }
            else if (avgScore >= 2.5) { overallRating = 'Gut'; overallColor = '#ffff00'; }
            else if (avgScore >= 1.5) { overallRating = 'Akzeptabel'; overallColor = '#ffaa00'; }
            else { overallRating = 'Schwach'; overallColor = '#ff6600'; }

            // Format runtime
            const hours = Math.floor(runtime / 3600);
            const minutes = Math.floor((runtime % 3600) / 60);
            const seconds = Math.floor(runtime % 60);
            const runtimeStr = `${hours}h ${minutes}m ${seconds}s`;

            // Build results HTML
            let html = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                    <div>
                        <strong>üìä Messwerte:</strong><br>
                        ‚Ä¢ Kapazit√§t: <strong>${capacity.toFixed(0)} mAh</strong><br>
                        ‚Ä¢ Energie: <strong>${energy.toFixed(0)} mWh</strong><br>
                        ‚Ä¢ Testdauer: <strong>${runtimeStr}</strong><br>
                        ‚Ä¢ √ò Strom: <strong>${avgCurrent.toFixed(3)} A</strong><br>
                        ‚Ä¢ √ò Innenwiderstand: <strong>${avgResistance > 0 ? (avgResistance * 1000).toFixed(1) + ' mŒ©' : 'N/A'}</strong>
                    </div>
                    <div>
                        <strong>üìà Spannungsverlauf:</strong><br>
                        ‚Ä¢ Start: <strong>${startVoltage.toFixed(3)} V</strong><br>
                        ‚Ä¢ Ende: <strong>${endVoltage.toFixed(3)} V</strong><br>
                        ‚Ä¢ Abfall: <strong>${voltageDrop.toFixed(3)} V</strong><br>
                        ‚Ä¢ Rate: <strong>${voltageDropRate.toFixed(2)} V/h</strong>
                    </div>
                </div>

                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px;">
                    <strong>‚≠ê Bewertung:</strong><br><br>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <div>‚Ä¢ Kapazit√§t: <span style="color: ${capRating.color}; font-weight: bold;">${capRating.rating}</span></div>
                        <div>‚Ä¢ Innenwiderstand: <span style="color: ${resRating.color}; font-weight: bold;">${resRating.rating}</span></div>
                        <div>‚Ä¢ Spannungsstabilit√§t: <span style="color: ${voltRating.color}; font-weight: bold;">${voltRating.rating}</span></div>
                        <div>‚Ä¢ <strong>Gesamtbewertung: <span style="color: ${overallColor}; font-size: 1.1em;">${overallRating}</span></strong></div>
                    </div>
                </div>

                <div style="margin-top: 15px; font-size: 0.9rem; color: #aaa;">
                    <strong>Typische 18650-Werte:</strong> Kapazit√§t 2000-3500mAh, Innenwiderstand 20-80mŒ©
                </div>
            `;

            resultsDiv.innerHTML = html;
            analysisCard.style.display = 'block';

            log('üìä Testergebnis-Auswertung erstellt', 'info');
        }

        function updateDisplay(voltage, current, power, resistance, capacity, energy, temperature, runtime) {
            document.getElementById('voltage').innerHTML = `${voltage.toFixed(3)}<span class="status-unit">V</span>`;
            document.getElementById('current').innerHTML = `${current.toFixed(3)}<span class="status-unit">A</span>`;
            document.getElementById('power').innerHTML = `${power.toFixed(2)}<span class="status-unit">W</span>`;
            document.getElementById('resistance').innerHTML = `${resistance.toFixed(3)}<span class="status-unit">Œ©</span>`;
            document.getElementById('capacity').innerHTML = `${Math.round(capacity)}<span class="status-unit">mAh</span>`;
            document.getElementById('energy').innerHTML = `${Math.round(energy)}<span class="status-unit">mWh</span>`;
            document.getElementById('temperature').innerHTML = `${temperature.toFixed(2)}<span class="status-unit">¬∞C</span>`;
            
            const hours = Math.floor(runtime / 3600);
            const minutes = Math.floor((runtime % 3600) / 60);
            const seconds = Math.floor(runtime % 60);
            document.getElementById('runtime').textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            const cutoff = parseFloat(document.getElementById('cutoffVoltage').value);
            const maxTime = parseInt(document.getElementById('maxTime').value) * 60; // in seconds
            const startVoltage = dataPoints.length > 0 ? dataPoints[0].voltage : voltage;

            // Calculate voltage-based progress (only if startVoltage > cutoff)
            let voltageProgress = 0;
            if (startVoltage > cutoff && voltage <= startVoltage) {
                voltageProgress = ((startVoltage - voltage) / (startVoltage - cutoff)) * 100;
            }

            // Calculate time-based progress (if maxTime is set)
            const timeProgress = (maxTime > 0) ? (runtime / maxTime) * 100 : 0;

            // Use the higher progress (whichever condition is closer to completion)
            // Clamp between 0 and 100
            const progress = Math.max(0, Math.min(100, Math.max(voltageProgress, timeProgress)));

            document.getElementById('progressBar').style.width = `${progress}%`;
            document.getElementById('progressBar').parentElement.setAttribute('data-progress', `${progress.toFixed(2)}%`);
        }

        function exportData() {
            if (dataPoints.length === 0) {
                log('No data to export', 'warning');
                return;
            }

            // Export ALL values regardless of plot settings
            let csv = 'Time (s),Voltage (V),Current (A),Power (W),Resistance (Ohm),Capacity (mAh),Energy (mWh),Temperature (C)\n';
            dataPoints.forEach(point => {
                csv += `${point.time.toFixed(1)},${point.voltage.toFixed(3)},${point.current.toFixed(3)},${(point.power || 0).toFixed(3)},${(point.resistance || 0).toFixed(3)},${point.capacity.toFixed(1)},${(point.energy || 0).toFixed(1)},${(point.temperature || 0).toFixed(1)}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `battery_test_${new Date().toISOString().slice(0,10)}_${new Date().toTimeString().slice(0,5).replace(':','')}.csv`;
            a.click();

            log('Measure file exported as CSV', 'info');
        }

        // Auto-update cutoff voltage based on battery type
        document.getElementById('batteryType').addEventListener('change', function() {
            const type = this.value;
            if (type === 'liion') {
                document.getElementById('cutoffVoltage').value = 2.5;
            }
            // Keep current value for 'custom'
        });

         // Load Struggle Detection - Improved with stability and hysteresis
        function checkLoadStruggle(current, setCurrent, voltage, cutoffVoltage) {
            if (!testRunning || setCurrent <= 0) {
                loadStruggleDetected = false;
                hideLoadStruggleWarning();
                return;
            }

            // Add current to history
            currentHistory.push({
                current: current,
                timestamp: Date.now()
            });

            // Keep only last 30 seconds of history
            const cutoff = Date.now() - 30000;
            currentHistory = currentHistory.filter(entry => entry.timestamp > cutoff);

            if (currentHistory.length < 20) return; // Need at least 20 samples for stability

            // Calculate average current over last 30 seconds
            const avgCurrent = currentHistory.reduce((sum, entry) => sum + entry.current, 0) / currentHistory.length;

            // More conservative thresholds with hysteresis
            const expectedMinCurrent = setCurrent * 0.80; // 20% tolerance for detection
            const recoveryCurrent = setCurrent * 0.90;   // 10% tolerance for recovery

            // Check if voltage is too low (battery can't deliver current)
            const voltageStruggle = voltage < (cutoffVoltage + 0.3); // Within 0.3V of cutoff

            // Detect load struggle - needs to be persistent
            const currentStruggle = avgCurrent < expectedMinCurrent;

            // For detection: require both conditions OR severe voltage struggle
            const shouldDetectStruggle = (currentStruggle && voltageStruggle) ||
                                       (avgCurrent < setCurrent * 0.7) || // Very low current
                                       (voltage < cutoffVoltage + 0.1);       // Very low voltage

            // For recovery: need better conditions
            const shouldRecover = avgCurrent > recoveryCurrent && voltage > (cutoffVoltage + 0.6);

            if (shouldDetectStruggle && !loadStruggleDetected) {
                loadStruggleDetected = true;
                showLoadStruggleWarning(current, setCurrent, voltage, cutoffVoltage);
            } else if (shouldRecover && loadStruggleDetected) {
                loadStruggleDetected = false;
                hideLoadStruggleWarning();
            }
        }

        function showLoadStruggleWarning(current, setCurrent, voltage, cutoffVoltage) {
            const warning = document.getElementById('loadStruggleWarning');
            const warningText = document.getElementById('loadStruggleText');

            const currentDrop = ((setCurrent - current) / setCurrent * 100).toFixed(1);
            const voltageStatus = voltage < (cutoffVoltage + 0.2) ? 'CRITICAL' : 'WARNING';

            if (voltage < (cutoffVoltage + 0.2)) {
                warningText.textContent = `BATTERY EXHAUSTED! Voltage: ${voltage.toFixed(2)}V (Cut-off: ${cutoffVoltage.toFixed(2)}V)`;
            } else if (voltage < (cutoffVoltage + 0.5)) {
                warningText.textContent = `Low voltage: ${voltage.toFixed(2)}V - Current dropped ${currentDrop}% (Expected: ${setCurrent.toFixed(2)}A)`;
            } else {
                warningText.textContent = `Current dropped ${currentDrop}% - ${current.toFixed(2)}A (Expected: ${setCurrent.toFixed(2)}A) - Check connections!`;
            }

            warning.style.display = 'block';
            log(`‚ö†Ô∏è LOAD STRUGGLE: Current ${current.toFixed(2)}A (expected ${setCurrent.toFixed(2)}A), Voltage ${voltage.toFixed(2)}V`, 'error');
        }

        function hideLoadStruggleWarning() {
            const warning = document.getElementById('loadStruggleWarning');
            // Only log if warning was actually visible
            if (warning.style.display !== 'none') {
                log('‚úÖ Load struggle resolved', 'info');
            }
            warning.style.display = 'none';
        }

        // Instant button state updates
        function updateButtonStatesInstant(running) {
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');

            if (running) {
                startBtn.disabled = true;
                stopBtn.disabled = false;
                startBtn.textContent = '‚ñ∂ Start Test';
                stopBtn.textContent = '‚èπ Stop Test';
            } else {
                startBtn.disabled = false;
                stopBtn.disabled = true;
                startBtn.textContent = '‚ñ∂ Start Test';
                stopBtn.textContent = '‚èπ Stop Test';
            }
        }

        // Update chart plotting options
        function updateChartOptions() {
            plotOptions.voltage = document.getElementById('plotVoltage').checked;
            plotOptions.current = document.getElementById('plotCurrent').checked;
            plotOptions.power = document.getElementById('plotPower').checked;
            plotOptions.resistance = document.getElementById('plotResistance').checked;
            plotOptions.capacity = document.getElementById('plotCapacity').checked;
            plotOptions.energy = document.getElementById('plotEnergy').checked;
            plotOptions.temperature = document.getElementById('plotTemperature').checked;

            // Force chart redraw if it exists
            if (chart && chart.data && chart.data.length > 0) {
                chart.draw();
            }
        }

        // Update System Status Display
        function updateSystemStatus(result, data) {
            // Connection status - Check if elements exist before accessing
            const connectionDot = document.getElementById('connectionDot');
            const connectionText = document.getElementById('connectionText');
            if (connectionDot && connectionText) {
                if (result.connected) {
                    connectionDot.className = 'indicator-dot connected';
                    connectionText.textContent = 'Connected';
                    connectionText.style.color = '#44ff44';
                } else {
                    connectionDot.className = 'indicator-dot disconnected';
                    connectionText.textContent = 'Disconnected';
                    connectionText.style.color = '#ff4444';
                }
            }

            // Load status - Check if elements exist before accessing
            const loadDot = document.getElementById('loadDot');
            const loadText = document.getElementById('loadText');
            if (loadDot && loadText) {
                if (result.load_on) {
                    loadDot.className = 'indicator-dot active';
                    loadText.textContent = 'ON';
                    loadText.style.color = '#ffaa00';
                } else {
                    loadDot.className = 'indicator-dot inactive';
                    loadText.textContent = 'OFF';
                    loadText.style.color = '#666';
                }
            }

            // Test status - Check if elements exist before accessing
            const testDot = document.getElementById('testDot');
            const testStatusText = document.getElementById('testStatusText');
            if (testDot && testStatusText) {
                if (result.running) {
                    testDot.className = 'indicator-dot active';
                    testStatusText.textContent = 'Running';
                    testStatusText.style.color = '#ffaa00';
                } else {
                    testDot.className = 'indicator-dot inactive';
                    testStatusText.textContent = 'Idle';
                    testStatusText.style.color = '#666';
                }
            }

            // Set current and cutoff - Check if elements exist
            const setCurrentText = document.getElementById('setCurrentText');
            const cutoffText = document.getElementById('cutoffText');
            if (setCurrentText) {
                setCurrentText.textContent = result.set_current.toFixed(2) + ' A';
            }
            if (cutoffText) {
                cutoffText.textContent = result.cutoff_voltage.toFixed(2) + ' V';
            }

            // Last update time - Check if element exists
            const lastUpdateText = document.getElementById('lastUpdateText');
            if (lastUpdateText) {
                const now = new Date();
                lastUpdateText.textContent = now.toLocaleTimeString('de-DE');
            }

            // Update button states based on actual device status - Check if buttons exist
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');

            if (startBtn && stopBtn) {
                // Check if load is actually drawing current (ON + current > 0.01A)
                // Also consider frontend testRunning state for robustness against comm errors
                const isActuallyRunning = (result.load_on && data.current > 0.01) || testRunning || result.running;

                if (isActuallyRunning) {
                    // Device is actively discharging - only show stop button
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    startBtn.textContent = '‚ñ∂ Start Test';
                    stopBtn.textContent = '‚èπ Stop Test';

                    // Update testRunning state to match reality
                    if (!testRunning && result.load_on && data.current > 0.01) {
                        testRunning = true;
                        log('üîã Device is actively discharging - test state synchronized', 'info');
                    }
                } else {
                    // Device is idle - show start button
                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    startBtn.textContent = '‚ñ∂ Start Test';
                    stopBtn.textContent = '‚èπ Stop Test';
                }
            }
        }

        async function updateStatus() {
            if (!SIMULATION_MODE) {
                try {
                    const response = await fetch(`${API_BASE}/status`);
                    const result = await response.json();

                    if (result.data) {
                        const data = result.data;
                        const runtime = data.runtime;

                        // Update System Status
                        updateSystemStatus(result, data);

                        // Update connection health display
                        if (result.connection_health) {
                            updateConnectionHealth(result.connection_health);
                        }

                        // Update device status displays
                        const loadOnText = result.load_on ? 'ON' : 'OFF';
                        const loadOnColor = result.load_on ? '#44ff44' : '#ff4444';

                        // Update both load status displays
                        const loadText = document.getElementById('loadText');
                        const loadStatusDisplay = document.getElementById('loadStatusDisplay');
                        if (loadText) {
                            loadText.textContent = loadOnText;
                            loadText.style.color = loadOnColor;
                        }
                        if (loadStatusDisplay) {
                            loadStatusDisplay.textContent = loadOnText;
                            loadStatusDisplay.style.color = loadOnColor;
                        }

                        document.getElementById('cutoffDisplay').textContent = result.cutoff_voltage.toFixed(2) + 'V';
                        document.getElementById('setCurrentDisplay').textContent = result.set_current.toFixed(2) + 'A';

                        updateDisplay(
                            data.voltage,
                            data.current,
                            data.power,
                            data.resistance,
                            data.capacity,
                            data.energy,
                            data.temperature,
                            runtime
                        );

                        // Check for load struggle
                        checkLoadStruggle(data.current, result.set_current, data.voltage, result.cutoff_voltage);

                        dataPoints.push({
                            time: runtime,
                            voltage: data.voltage,
                            current: data.current,
                            power: data.power,
                            resistance: data.resistance,
                            capacity: data.capacity,
                            energy: data.energy,
                            temperature: data.temperature
                        });

                        if (chart) {
                            chart.data = dataPoints;
                            chart.draw();
                        }

                        // Check if test stopped automatically
                        if (!result.running && testRunning) {
                            stopTest();
                        }
                    }
                } catch (error) {
                    log(`Status update failed: ${error.message}`, 'error');
                }
            }
        }

        async function checkConnection() {
            if (!SIMULATION_MODE) {
                try {
                    const response = await fetch(`${API_BASE}/status`);
                    const result = await response.json();

                    if (result.connected) {
                        log('‚úÖ Connected to DL24P', 'info');
                        document.getElementById('statusMessage').textContent = '‚úÖ Connected - Ready for 18650 test';
                        document.getElementById('statusMessage').className = 'info-box';
                    } else {
                        log('‚ö†Ô∏è Device not connected', 'warning');
                        document.getElementById('statusMessage').textContent = '‚ö†Ô∏è Device not connected - Check connection';
                    }
                } catch (error) {
                    log('‚ùå No connection to server', 'error');
                    log('Please start: ./dl24_webserver.py', 'warning');
                    document.getElementById('statusMessage').textContent = '‚ùå Server not reachable';
                    document.getElementById('statusMessage').className = 'warning-box';
                }
            }
        }

        async function refreshPorts() {
            if (SIMULATION_MODE) {
                // Simulation mode - show dummy ports
                const portSelect = document.getElementById('portSelect');
                portSelect.innerHTML = `
                    <option value="/dev/ttyUSB0">/dev/ttyUSB0 (Simulation)</option>
                    <option value="/dev/ttyUSB1">/dev/ttyUSB1 (Simulation)</option>
                `;
                log('üîÑ Port list refreshed (simulation mode)', 'info');
                return;
            }

            try {
                log('üîÑ Refreshing port list...', 'info');
                const response = await fetch(`${API_BASE}/ports`);
                const result = await response.json();

                if (result.success) {
                    const portSelect = document.getElementById('portSelect');
                    portSelect.innerHTML = '';

                    if (result.ports.length === 0) {
                        portSelect.innerHTML = '<option value="">No ports found</option>';
                        log('‚ö†Ô∏è No serial ports detected', 'warning');
                    } else {
                        result.ports.forEach(port => {
                            const option = document.createElement('option');
                            option.value = port.device;
                            option.textContent = `${port.device} - ${port.description}`;

                            // Select current port if it matches
                            if (port.device === result.current.serport) {
                                option.selected = true;
                            }

                            portSelect.appendChild(option);
                        });

                        log(`‚úÖ Found ${result.ports.length} serial port(s)`, 'info');

                        // Show current port
                        if (result.current.serport) {
                            log(`üìå Current port: ${result.current.serport}`, 'info');
                        }
                    }
                } else {
                    log(`‚ùå Failed to list ports: ${result.error}`, 'error');
                    const portSelect = document.getElementById('portSelect');
                    portSelect.innerHTML = '<option value="">Error loading ports</option>';
                }
            } catch (error) {
                log(`‚ùå Error refreshing ports: ${error.message}`, 'error');
                const portSelect = document.getElementById('portSelect');
                portSelect.innerHTML = '<option value="">Server not reachable</option>';
            }
        }

        async function connectToPort() {
            if (SIMULATION_MODE) {
                log('‚úÖ Port connected (simulation mode)', 'info');
                return;
            }

            const portSelect = document.getElementById('portSelect');
            const selectedPort = portSelect.value;

            if (!selectedPort) {
                log('‚ö†Ô∏è Please select a port first', 'warning');
                return;
            }

            try {
                log(`üîå Connecting to ${selectedPort}...`, 'info');

                const response = await fetch(`${API_BASE}/set_port`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ port: selectedPort })
                });

                const result = await response.json();

                if (result.success) {
                    log(`‚úÖ ${result.message}`, 'info');
                    // Refresh connection status
                    setTimeout(() => {
                        checkConnection();
                        updateStatus();
                    }, 500);
                } else {
                    log(`‚ùå Connection failed: ${result.error}`, 'error');
                }
            } catch (error) {
                log(`‚ùå Error connecting to port: ${error.message}`, 'error');
            }
        }

        async function reconnectDevice() {
            if (SIMULATION_MODE) {
                log('‚úÖ Reconnected (simulation mode)', 'info');
                return;
            }

            const reconnectBtn = document.getElementById('reconnectBtn');
            reconnectBtn.disabled = true;
            reconnectBtn.textContent = '...';

            try {
                log('üîÑ Attempting reconnection...', 'info');

                const response = await fetch(`${API_BASE}/reconnect`, {
                    method: 'POST'
                });

                const result = await response.json();

                if (result.success) {
                    log(`‚úÖ ${result.message}`, 'info');
                    reconnectBtn.style.display = 'none';
                    setTimeout(() => {
                        checkConnection();
                        updateStatus();
                    }, 500);
                } else {
                    log(`‚ùå Reconnection failed: ${result.error}`, 'error');
                }
            } catch (error) {
                log(`‚ùå Error during reconnection: ${error.message}`, 'error');
            } finally {
                reconnectBtn.disabled = false;
                reconnectBtn.textContent = 'Reconnect';
            }
        }

        function updateConnectionHealth(health) {
            const healthRow = document.getElementById('connectionHealthRow');
            const healthText = document.getElementById('connectionHealthText');
            const reconnectBtn = document.getElementById('reconnectBtn');

            if (!health) return;

            // Show reconnect button if there are connection issues
            if (health.consecutive_failures > 0 || health.last_error) {
                reconnectBtn.style.display = 'inline-block';
                healthRow.style.display = 'flex';

                if (health.consecutive_failures >= 3) {
                    healthText.textContent = `‚ö†Ô∏è ${health.consecutive_failures} failures`;
                    healthText.style.color = '#ff4444';
                } else if (health.consecutive_failures > 0) {
                    healthText.textContent = `${health.consecutive_failures} failure(s)`;
                    healthText.style.color = '#ffaa00';
                }

                if (health.last_error) {
                    healthText.title = health.last_error;
                }
            } else {
                reconnectBtn.style.display = 'none';
                healthRow.style.display = 'none';
            }
        }

        // Update system time display
        function updateSystemTime() {
            const timeEl = document.getElementById('systemTimeText');
            if (timeEl) {
                const now = new Date();
                timeEl.textContent = now.toLocaleTimeString('de-DE', {
                    timeZone: 'Europe/Berlin',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            }
        }

        // Initialize WebSocket connection
        function initWebSocket() {
            if (SIMULATION_MODE) return;

            try {
                socket = io(`${window.location.protocol}//${window.location.hostname}:5000`);

                socket.on('connect', () => {
                    log('üîå WebSocket connected', 'info');
                });

                socket.on('disconnect', () => {
                    log('‚ö†Ô∏è WebSocket disconnected', 'warning');
                });

                socket.on('status_update', (result) => {
                    if (result.data) {
                        const data = result.data;
                        const runtime = data.runtime;

                        // Update System Status
                        updateSystemStatus(result, data);

                        // Update connection health display
                        if (result.connection_health) {
                            updateConnectionHealth(result.connection_health);
                        }

                        // Update device status displays
                        const loadOnText = result.load_on ? 'ON' : 'OFF';
                        const loadOnColor = result.load_on ? '#44ff44' : '#ff4444';

                        const loadText = document.getElementById('loadText');
                        const loadStatusDisplay = document.getElementById('loadStatusDisplay');
                        if (loadText) {
                            loadText.textContent = loadOnText;
                            loadText.style.color = loadOnColor;
                        }
                        if (loadStatusDisplay) {
                            loadStatusDisplay.textContent = loadOnText;
                            loadStatusDisplay.style.color = loadOnColor;
                        }

                        document.getElementById('cutoffDisplay').textContent = result.cutoff_voltage.toFixed(2) + 'V';
                        document.getElementById('setCurrentDisplay').textContent = result.set_current.toFixed(2) + 'A';

                        updateDisplay(
                            data.voltage,
                            data.current,
                            data.power,
                            data.resistance,
                            data.capacity,
                            data.energy,
                            data.temperature,
                            runtime
                        );

                        // Check for load struggle
                        checkLoadStruggle(data.current, result.set_current, data.voltage, result.cutoff_voltage);

                        // Record data point if test is running
                        if (testRunning && runtime > 0) {
                            dataPoints.push({
                                time: runtime,
                                voltage: data.voltage,
                                current: data.current,
                                power: data.power,
                                resistance: data.resistance,
                                capacity: data.capacity,
                                energy: data.energy,
                                temperature: data.temperature
                            });

                            if (chart) {
                                chart.data = dataPoints;
                                chart.draw();
                            }
                        }

                        // Check if test stopped automatically
                        if (!result.running && testRunning) {
                            stopTest();
                        }
                    }
                });

                socket.on('connect_error', (error) => {
                    log(`‚ùå WebSocket error: ${error.message}`, 'error');
                });

            } catch (error) {
                log(`‚ùå WebSocket initialization failed: ${error.message}`, 'error');
            }
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initChart();
            log('18650 Battery Test Manager started', 'info');

            // Start system time clock
            updateSystemTime();
            setInterval(updateSystemTime, 1000);

            // Load saved custom cycles from localStorage
            updateCycleDropdown();

            if (SIMULATION_MODE) {
                log('‚ö†Ô∏è SIMULATION MODE active', 'warning');
                log('System ready for demo tests', 'info');
                refreshPorts();
            } else {
                log('Connecting to backend...', 'info');
                checkConnection();
                refreshPorts();
                initWebSocket();  // Initialize WebSocket for real-time updates

                // Fallback polling every 5 seconds (in case WebSocket fails)
                setInterval(() => {
                    if (!socket || !socket.connected) {
                        updateStatus();
                    }
                }, 5000);
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (chart) {
                chart.draw();
            }
        });

        // Safety: Stop test when browser closes
        window.addEventListener('beforeunload', (event) => {
            if (testRunning && !SIMULATION_MODE) {
                // Send synchronous stop request
                navigator.sendBeacon(`${API_BASE}/stop`, '');
                log('‚ö†Ô∏è Browser closing - stopping test', 'warning');
            }
        });

        // Heartbeat to keep connection alive
        if (!SIMULATION_MODE) {
            setInterval(() => {
                fetch(`${API_BASE}/heartbeat`, { method: 'POST' }).catch(() => {});
            }, 5000);
        }
    </script>
</body>
</html>
