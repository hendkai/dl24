<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATorch DL24P - 18650 Test Manager</title>
    <style>
        :root {
            --color-bg: #1a1a2e;
            --color-surface: #16213e;
            --color-primary: #0f3460;
            --color-accent: #e94560;
            --color-success: #00d9ff;
            --color-text: #eaeaea;
            --color-text-dim: #a0a0a0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--color-bg);
            color: var(--color-text);
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: var(--color-surface);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        h1 {
            color: var(--color-success);
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .subtitle {
            color: var(--color-text-dim);
            font-size: 1.1rem;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 968px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: var(--color-surface);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        .card h2 {
            color: var(--color-success);
            margin-bottom: 20px;
            font-size: 1.5rem;
            border-bottom: 2px solid var(--color-primary);
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: var(--color-text);
            font-weight: 500;
        }

        input, select {
            width: 100%;
            padding: 12px;
            background: var(--color-primary);
            border: 2px solid var(--color-primary);
            border-radius: 8px;
            color: var(--color-text);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--color-success);
            background: rgba(0, 217, 255, 0.1);
        }

        .btn {
            padding: 14px 28px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: var(--color-success);
            color: var(--color-bg);
        }

        .btn-primary:hover {
            background: #00b8d4;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 217, 255, 0.4);
        }

        .btn-danger {
            background: var(--color-accent);
            color: white;
        }

        .btn-danger:hover {
            background: #c23854;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(233, 69, 96, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .status-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .status-item {
            background: var(--color-primary);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .status-label {
            font-size: 0.9rem;
            color: var(--color-text-dim);
            margin-bottom: 5px;
        }

        .status-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--color-success);
        }

        .status-unit {
            font-size: 1rem;
            color: var(--color-text-dim);
            margin-left: 5px;
        }

        #log {
            background: var(--color-bg);
            padding: 15px;
            border-radius: 8px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            border: 2px solid var(--color-primary);
        }

        .log-entry {
            padding: 5px;
            border-bottom: 1px solid var(--color-primary);
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .log-info { color: var(--color-success); }
        .log-warning { color: #ffd700; }
        .log-error { color: var(--color-accent); }
        .log-data { color: var(--color-text-dim); }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: var(--color-primary);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--color-success), #00b8d4);
            width: 0%;
            transition: width 0.5s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--color-bg);
            font-weight: bold;
        }

        .chart-container {
            margin-top: 20px;
            background: var(--color-bg);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid var(--color-primary);
        }

        canvas {
            width: 100% !important;
            height: 400px !important; /* Increased height for better resolution */
            image-rendering: crisp-edges;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
        }

        /* System Status Styles */
        .system-status {
            background: var(--color-bg);
            padding: 20px;
            border-radius: 8px;
            border: 2px solid var(--color-primary);
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 217, 255, 0.1);
        }

        .status-row:last-child {
            border-bottom: none;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .indicator-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #666;
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
        }

        .indicator-dot.connected {
            background: var(--color-success);
            box-shadow: 0 0 10px var(--color-success);
        }

        .indicator-dot.disconnected {
            background: var(--color-danger);
            box-shadow: 0 0 10px var(--color-danger);
        }

        .indicator-dot.active {
            background: var(--color-warning);
            box-shadow: 0 0 15px var(--color-warning);
            animation: pulse 1s infinite;
        }

        .indicator-dot.inactive {
            background: #666;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        .indicator-label {
            color: var(--color-text);
            font-weight: 500;
        }

        .status-value {
            color: var(--color-success);
            font-family: monospace;
            font-weight: bold;
        }

        /* Enhanced button states */
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn:disabled:hover {
            transform: none !important;
        }

        .btn.btn-loading {
            background: linear-gradient(45deg, var(--color-warning), var(--color-success));
            animation: button-loading 1s infinite;
        }

        @keyframes button-loading {
            0% { opacity: 1; }
            50% { opacity: 0.8; }
            100% { opacity: 1; }
        }

        @keyframes warning-pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
            }
            50% {
                transform: scale(1.02);
                box-shadow: 0 0 20px rgba(255, 170, 0, 0.8);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 10px rgba(255, 170, 0, 0.5);
            }
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 15px;
        }

        .preset-btn {
            padding: 10px;
            background: var(--color-primary);
            border: 2px solid var(--color-success);
            border-radius: 8px;
            color: var(--color-text);
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .preset-btn:hover {
            background: var(--color-success);
            color: var(--color-bg);
            transform: scale(1.05);
        }

        .phase-item {
            background: var(--color-bg);
            padding: 10px;
            margin: 10px 0;
            border-radius: 6px;
            border-left: 3px solid var(--color-success);
        }

        .phase-header {
            font-weight: bold;
            color: var(--color-success);
            margin-bottom: 5px;
        }

        .phase-details {
            color: var(--color-text-dim);
            font-size: 0.9rem;
            margin-left: 10px;
        }

        .cycle-param {
            display: inline-block;
            margin-right: 15px;
            padding: 3px 8px;
            background: rgba(0, 217, 255, 0.1);
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .info-box {
            background: rgba(0, 217, 255, 0.1);
            border-left: 4px solid var(--color-success);
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
        }

        .warning-box {
            background: rgba(255, 215, 0, 0.1);
            border-left: 4px solid #ffd700;
            padding: 15px;
            margin: 20px 0;
            border-radius: 4px;
            color: #ffd700;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>‚ö° ATorch DL24P - 18650 Test Manager</h1>
            <p class="subtitle">Automated 18650 Li-Ion battery discharge testing with data logging and visualization</p>
        </header>

        <div class="grid">
            <div class="card">
                <h2>üîã Test Parameters</h2>
                
                <div class="form-group">
                    <label for="batteryType">Battery Type</label>
                    <select id="batteryType">
                        <option value="liion" selected>18650 Li-Ion (2.5V - 4.2V)</option>
                        <option value="custom">Custom Settings</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="dischargeCurrent">Discharge Current (A)</label>
                    <input type="number" id="dischargeCurrent" value="1.0" min="0.1" max="20" step="0.1">
                </div>

                <div class="form-group">
                    <label for="cutoffVoltage">Cut-off Voltage (V)</label>
                    <input type="number" id="cutoffVoltage" value="2.5" min="0.1" max="60" step="0.1">
                </div>

                <div class="form-group">
                    <label for="maxTime">Max Time (minutes, 0 = unlimited)</label>
                    <input type="number" id="maxTime" value="0" min="0" max="1440" step="1">
                </div>

                <div class="form-group">
                    <label for="logInterval">Log Interval (seconds)</label>
                    <input type="number" id="logInterval" value="1" min="1" max="60" step="1">
                </div>

                <div class="form-group">
                    <label for="testCycle">Test Cycle Profile</label>
                    <select id="testCycle" onchange="loadTestCycle()">
                        <option value="simple">Simple Discharge</option>
                        <option value="basic_capacity">Basic Capacity Test (1A, 2-4h)</option>
                        <option value="slow_capacity">Slow Capacity Test (0.5A, 5-8h)</option>
                        <option value="fast_screening">Fast Screening (2A, 1-2h)</option>
                        <option value="advanced_stress">Advanced Stress Test (6-8h)</option>
                        <option value="custom">Custom Cycle...</option>
                    </select>
                </div>

                <div id="cycleDetails" class="info-box" style="display: none;">
                    <strong>Cycle Details:</strong>
                    <div id="cycleDescription" style="margin: 10px 0; color: var(--color-text-dim);"></div>
                    <div id="cyclePhases"></div>
                    <button class="btn btn-primary" onclick="toggleCycleEditor()" style="margin-top: 10px; padding: 8px 16px; font-size: 0.9rem;">‚úèÔ∏è Edit Cycle</button>
                </div>

                <div id="cycleEditor" style="display: none; margin-top: 15px; padding: 15px; background: var(--color-primary); border-radius: 8px;">
                    <h3 style="margin-bottom: 15px; color: var(--color-success);">Cycle Editor</h3>

                    <div class="form-group">
                        <label>Cycle Name</label>
                        <input type="text" id="customCycleName" placeholder="My Custom Test">
                    </div>

                    <div class="form-group">
                        <label>Number of Phases</label>
                        <input type="number" id="numPhases" value="1" min="1" max="5" onchange="updatePhaseEditor()">
                    </div>

                    <div id="phaseEditor"></div>

                    <div class="btn-group" style="margin-top: 15px;">
                        <button class="btn btn-primary" onclick="applyCustomCycle()">‚úîÔ∏è Apply Cycle</button>
                        <button class="btn btn-danger" onclick="cancelCycleEdit()">‚úñÔ∏è Cancel</button>
                    </div>
                </div>

                <div class="btn-group">
                    <button id="startBtn" class="btn btn-primary" onclick="startTest()">‚ñ∂ Start Test</button>
                    <button id="stopBtn" class="btn btn-danger" onclick="stopTest()" disabled>‚èπ Stop Test</button>
                </div>
            </div>

            <div class="card">
                <h2>üîß System Status</h2>
                <div class="system-status">
                    <div class="status-row">
                        <div class="status-indicator" id="connectionStatus">
                            <span class="indicator-dot" id="connectionDot"></span>
                            <span class="indicator-label">Device Connection</span>
                        </div>
                        <div class="status-value" id="connectionText">Checking...</div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator">
                            <span class="indicator-label">Serial Port</span>
                        </div>
                        <div style="display: flex; gap: 8px; align-items: center;">
                            <select id="portSelect" style="flex: 1; padding: 6px; background: var(--color-primary); border: 1px solid var(--color-success); border-radius: 4px; color: var(--color-text); font-size: 0.9rem;">
                                <option value="">Loading...</option>
                            </select>
                            <button onclick="refreshPorts()" style="padding: 6px 12px; background: var(--color-success); border: none; border-radius: 4px; color: var(--color-bg); cursor: pointer; font-size: 0.85rem; font-weight: 600;">üîÑ</button>
                            <button onclick="connectToPort()" style="padding: 6px 12px; background: var(--color-primary); border: 2px solid var(--color-success); border-radius: 4px; color: var(--color-text); cursor: pointer; font-size: 0.85rem; font-weight: 600;">Connect</button>
                        </div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator" id="loadStatus">
                            <span class="indicator-dot" id="loadDot"></span>
                            <span class="indicator-label">Load Status</span>
                        </div>
                        <div class="status-value" id="loadText">OFF</div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator" id="testStatus">
                            <span class="indicator-dot" id="testDot"></span>
                            <span class="indicator-label">Test Status</span>
                        </div>
                        <div class="status-value" id="testStatusText">Idle</div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator">
                            <span class="indicator-label">Set Current</span>
                        </div>
                        <div class="status-value" id="setCurrentText">0.00 A</div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator">
                            <span class="indicator-label">Cutoff Voltage</span>
                        </div>
                        <div class="status-value" id="cutoffText">0.00 V</div>
                    </div>
                    <div class="status-row">
                        <div class="status-indicator">
                            <span class="indicator-label">Last Update</span>
                        </div>
                        <div class="status-value" id="lastUpdateText">Never</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h2>üìä Live Data</h2>
                
                <div class="status-display">
                    <div class="status-item">
                        <div class="status-label">Voltage</div>
                        <div class="status-value" id="voltage">0.00<span class="status-unit">V</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Current</div>
                        <div class="status-value" id="current">0.00<span class="status-unit">A</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Power</div>
                        <div class="status-value" id="power">0.00<span class="status-unit">W</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Resistance</div>
                        <div class="status-value" id="resistance">0.00<span class="status-unit">Œ©</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Capacity</div>
                        <div class="status-value" id="capacity">0<span class="status-unit">mAh</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Energy</div>
                        <div class="status-value" id="energy">0<span class="status-unit">mWh</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Temperature</div>
                        <div class="status-value" id="temperature">0<span class="status-unit">¬∞C</span></div>
                    </div>
                    <div class="status-item">
                        <div class="status-label">Runtime</div>
                        <div class="status-value" id="runtime">00:00:00</div>
                    </div>
                </div>

                <div class="progress-bar">
                    <div class="progress-fill" id="progressBar">0%</div>
                </div>

                <!-- Device Status Info -->
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; margin-top: 15px; font-size: 12px;">
                    <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                        <div style="color: #aaa; font-size: 10px;">Set Current</div>
                        <div id="setCurrentDisplay" style="font-weight: bold; color: #44ff44;">1.00A</div>
                    </div>
                    <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                        <div style="color: #aaa; font-size: 10px;">Load Status</div>
                        <div id="loadStatus" style="font-weight: bold; color: #ff4444;">OFF</div>
                    </div>
                    <div style="text-align: center; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
                        <div style="color: #aaa; font-size: 10px;">Cutoff Voltage</div>
                        <div id="cutoffDisplay" style="font-weight: bold;">3.00V</div>
                    </div>
                </div>

                <div class="warning-box" id="statusMessage">
                    ‚ö†Ô∏è Ready for test. Connect 18650 battery and verify parameters.
                </div>

                <!-- Load Struggle Warning -->
                <div class="warning-box" id="loadStruggleWarning" style="display: none; background: linear-gradient(45deg, #ff4444, #ff8800); border: 2px solid #ffaa00; animation: warning-pulse 1s infinite;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
                        <span style="font-size: 24px;">‚ö†Ô∏è</span>
                        <div>
                            <strong>LOAD STRUGGLE DETECTED!</strong><br>
                            <span id="loadStruggleText">Current dropping significantly - Check battery connections!</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>üìà Discharge Curve</h2>

            <!-- Plot Selection Controls -->
            <div style="background: rgba(0,217,255,0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                <div style="display: flex; gap: 20px; align-items: center; flex-wrap: wrap;">
                    <div style="font-weight: bold; color: #00d9ff;">Plot Values:</div>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotVoltage" checked onchange="updateChartOptions()">
                        <span>‚ö° Voltage</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotCurrent" checked onchange="updateChartOptions()">
                        <span>üîã Current</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotPower" onchange="updateChartOptions()">
                        <span>‚ö° Power</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotResistance" onchange="updateChartOptions()">
                        <span>Œ© Resistance</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotCapacity" checked onchange="updateChartOptions()">
                        <span>üîã Capacity</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotEnergy" onchange="updateChartOptions()">
                        <span>‚ö° Energy</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="plotTemperature" onchange="updateChartOptions()">
                        <span>üå° Temperature</span>
                    </label>
                </div>
            </div>

            <div class="chart-container">
                <canvas id="chart"></canvas>
            </div>
        </div>

        <div class="card">
            <h2>üìù Test Log</h2>
            <div id="log"></div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="exportData()">üíæ Export Data (CSV)</button>
                <button class="btn btn-primary" onclick="clearLog()">üóëÔ∏è Clear Log</button>
            </div>
        </div>
    </div>

    <script>
        // Backend API URL
        const API_BASE = 'http://localhost:5000/api';
        const SIMULATION_MODE = false;  // Set to true for demo without hardware

        let testRunning = false;
        let testStartTime = null;
        let testInterval = null;
        let statusInterval = null;
        let dataPoints = [];
        let chart = null;

        // Load struggle detection
        let currentHistory = [];
        let expectedCurrent = 0;
        let loadStruggleDetected = false;

        // Chart plotting options
        let plotOptions = {
            voltage: true,
            current: true,
            power: false,
            resistance: false,
            capacity: true,
            energy: false,
            temperature: false
        };

        // 18650 Battery presets
        const presets = {
            '18650_0.5A': { type: 'liion', current: 0.5, cutoff: 2.5 },
            '18650_1.0A': { type: 'liion', current: 1.0, cutoff: 2.5 },
            '18650_2.0A': { type: 'liion', current: 2.0, cutoff: 2.5 }
        };

        // Test cycle definitions with phases
        const testCycles = {
            'simple': {
                name: 'Simple Discharge',
                description: 'Single constant-current discharge',
                phases: [
                    { name: 'Discharge', type: 'discharge', current: 1.0, cutoff: 2.5, maxTime: 0 }
                ]
            },
            'basic_capacity': {
                name: 'Basic Capacity Test',
                description: 'Standard 1A discharge for capacity verification (2-4h)',
                phases: [
                    { name: 'Initial Rest', type: 'rest', duration: 60 },
                    { name: 'Discharge', type: 'discharge', current: 1.0, cutoff: 2.5, maxTime: 240 }
                ]
            },
            'slow_capacity': {
                name: 'Slow Capacity Test',
                description: 'Low-rate 0.5A discharge for accurate capacity (5-8h)',
                phases: [
                    { name: 'Extended Rest', type: 'rest', duration: 120 },
                    { name: 'Slow Discharge', type: 'discharge', current: 0.5, cutoff: 2.5, maxTime: 480 }
                ]
            },
            'fast_screening': {
                name: 'Fast Screening',
                description: 'High-rate 2A discharge for quick screening (1-2h)',
                phases: [
                    { name: 'Brief Rest', type: 'rest', duration: 30 },
                    { name: 'Fast Discharge', type: 'discharge', current: 2.0, cutoff: 2.5, maxTime: 120 }
                ]
            },
            'advanced_stress': {
                name: 'Advanced Stress Test',
                description: 'Multi-phase dynamic load testing (6-8h)',
                phases: [
                    { name: 'Initial Rest', type: 'rest', duration: 60 },
                    { name: 'Conditioning', type: 'discharge', current: 1.0, duration: 900 },
                    { name: 'Ramp Up', type: 'ramp', startCurrent: 1.0, endCurrent: 2.0, duration: 900 },
                    { name: 'Max Load', type: 'discharge', current: 2.0, duration: 900 },
                    { name: 'Ramp Down', type: 'ramp', startCurrent: 2.0, endCurrent: 1.0, duration: 900 },
                    { name: 'Final Discharge', type: 'discharge', current: 1.0, cutoff: 2.5, maxTime: 360 }
                ]
            },
            'custom': {
                name: 'Custom Cycle',
                description: 'User-defined test cycle',
                phases: [
                    { name: 'Discharge', type: 'discharge', current: 1.0, cutoff: 2.5, maxTime: 0 }
                ]
            }
        };

        let currentCycle = null;
        let customCycle = null;

        // Initialize chart
        function initChart() {
            const canvas = document.getElementById('chart');
            const ctx = canvas.getContext('2d');

            // Set actual canvas resolution for high DPI displays
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);

            chart = {
                ctx: ctx,
                data: [],
                animationFrame: 0,

                draw: function() {
                    const canvas = ctx.canvas;
                    const width = rect.width;
                    const height = rect.height;

                    // Clear with subtle gradient background
                    const gradient = ctx.createLinearGradient(0, 0, 0, height);
                    gradient.addColorStop(0, '#1a1a2e');
                    gradient.addColorStop(1, '#0f0f1e');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(0, 0, width, height);

                    if (this.data.length < 2) {
                        // Draw "No data" message
                        ctx.fillStyle = '#666';
                        ctx.font = '16px monospace';
                        ctx.textAlign = 'center';
                        ctx.fillText('Waiting for data...', width / 2, height / 2);
                        ctx.textAlign = 'left';
                        return;
                    }

                    // Draw enhanced grid
                    this.drawGrid(width, height);

                    // Draw modern voltage curve with gradient
                    this.drawVoltageCurve(width, height);

                    // Draw enhanced labels
                    this.drawLabels(width, height);
                },

                drawGrid: function(width, height) {
                    // Vertical grid lines
                    ctx.strokeStyle = 'rgba(0, 217, 255, 0.1)';
                    ctx.lineWidth = 1;
                    for (let i = 0; i <= 20; i++) {
                        const x = width * i / 20;
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, height);
                        ctx.stroke();
                    }

                    // Horizontal grid lines
                    for (let i = 0; i <= 10; i++) {
                        const y = height * i / 10;
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(width, y);
                        ctx.stroke();
                    }

                    // Draw axes
                    ctx.strokeStyle = 'rgba(0, 217, 255, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(40, 0);
                    ctx.lineTo(40, height - 25);
                    ctx.lineTo(width - 10, height - 25);
                    ctx.stroke();
                },

                drawVoltageCurve: function(width, height) {
                    if (this.data.length < 2) return;

                    const maxTime = this.data[this.data.length - 1].time;

                    // Define colors and scales for each metric
                    const metrics = {
                        voltage: {
                            color: '#3498db',
                            glowColor: '#00d9ff',
                            unit: 'V',
                            getMin: () => Math.min(...this.data.map(d => d.voltage)),
                            getMax: () => Math.max(...this.data.map(d => d.voltage)),
                            getValue: (d) => d.voltage
                        },
                        current: {
                            color: '#e74c3c',
                            glowColor: '#ff6b6b',
                            unit: 'A',
                            getMin: () => 0,
                            getMax: () => Math.max(...this.data.map(d => d.current), 1),
                            getValue: (d) => d.current
                        },
                        power: {
                            color: '#f39c12',
                            glowColor: '#ffd93d',
                            unit: 'W',
                            getMin: () => 0,
                            getMax: () => Math.max(...this.data.map(d => d.power), 1),
                            getValue: (d) => d.power
                        },
                        resistance: {
                            color: '#9b59b6',
                            glowColor: '#c39bd3',
                            unit: 'Œ©',
                            getMin: () => 0,
                            getMax: () => Math.max(...this.data.map(d => d.resistance || 0), 1),
                            getValue: (d) => d.resistance || 0
                        },
                        capacity: {
                            color: '#2ecc71',
                            glowColor: '#58d68d',
                            unit: 'mAh',
                            getMin: () => 0,
                            getMax: () => Math.max(...this.data.map(d => d.capacity), 100),
                            getValue: (d) => d.capacity
                        },
                        energy: {
                            color: '#e67e22',
                            glowColor: '#f0b27a',
                            unit: 'mWh',
                            getMin: () => 0,
                            getMax: () => Math.max(...this.data.map(d => d.energy), 100),
                            getValue: (d) => d.energy
                        },
                        temperature: {
                            color: '#1abc9c',
                            glowColor: '#48c9b0',
                            unit: '¬∞C',
                            getMin: () => Math.min(...this.data.map(d => d.temperature || 20), 10),
                            getMax: () => Math.max(...this.data.map(d => d.temperature || 30), 50),
                            getValue: (d) => d.temperature || 20
                        }
                    };

                    // Draw selected metrics
                    let legendY = 20;
                    Object.entries(metrics).forEach(([key, metric]) => {
                        if (plotOptions[key]) {
                            const minValue = metric.getMin();
                            const maxValue = metric.getMax();
                            const range = maxValue - minValue || 1;

                            // Create gradient for this metric
                            const curveGradient = ctx.createLinearGradient(0, 0, 0, height);
                            curveGradient.addColorStop(0, metric.color);
                            curveGradient.addColorStop(1, metric.glowColor);

                            // Draw the curve line
                            ctx.beginPath();
                            ctx.strokeStyle = curveGradient;
                            ctx.lineWidth = 2.5;
                            ctx.lineJoin = 'round';
                            ctx.lineCap = 'round';

                            // Add glow effect
                            ctx.shadowColor = metric.glowColor;
                            ctx.shadowBlur = 8;

                            this.data.forEach((point, i) => {
                                const x = 40 + (point.time / maxTime) * (width - 50);
                                const value = metric.getValue(point);
                                const y = height - 25 - ((value - minValue) / range) * (height - 50) * 0.9 - (height - 50) * 0.05;

                                if (i === 0) {
                                    ctx.moveTo(x, y);
                                } else {
                                    ctx.lineTo(x, y);
                                }
                            });

                            ctx.stroke();
                            ctx.shadowBlur = 0;

                            // Draw data points (limited for performance)
                            ctx.fillStyle = metric.color;
                            const step = Math.ceil(this.data.length / 50);
                            for (let i = 0; i < this.data.length; i += step) {
                                const point = this.data[i];
                                const x = 40 + (point.time / maxTime) * (width - 50);
                                const value = metric.getValue(point);
                                const y = height - 25 - ((value - minValue) / range) * (height - 50) * 0.9 - (height - 50) * 0.05;

                                ctx.beginPath();
                                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                                ctx.fill();
                            }

                            // Draw legend entry
                            ctx.fillStyle = metric.color;
                            ctx.font = 'bold 12px monospace';
                            ctx.textAlign = 'left';
                            ctx.fillText(`‚óè ${key.charAt(0).toUpperCase() + key.slice(1)}`, 10, legendY);

                            const lastValue = metric.getValue(this.data[this.data.length - 1]);
                            ctx.font = '11px monospace';
                            ctx.fillStyle = '#ccc';
                            ctx.fillText(`${lastValue.toFixed(2)} ${metric.unit}`, 100, legendY);

                            legendY += 15;
                        }
                    });
                },

                drawLabels: function(width, height) {
                    if (this.data.length < 2) return;

                    const maxTime = this.data[this.data.length - 1].time;
                    const maxVoltage = Math.max(...this.data.map(d => d.voltage));
                    const minVoltage = Math.min(...this.data.map(d => d.voltage));

                    // Enhanced font settings
                    ctx.fillStyle = '#ffffff';
                    ctx.font = 'bold 14px monospace';
                    ctx.textAlign = 'right';

                    // Y-axis labels
                    ctx.fillText(`${maxVoltage.toFixed(2)}V`, 35, 20);
                    ctx.fillText(`${(maxVoltage * 0.75).toFixed(2)}V`, 35, height * 0.25);
                    ctx.fillText(`${(maxVoltage * 0.5).toFixed(2)}V`, 35, height * 0.5);
                    ctx.fillText(`${(maxVoltage * 0.25).toFixed(2)}V`, 35, height * 0.75);
                    ctx.fillText(`${minVoltage.toFixed(2)}V`, 35, height - 25);

                    // Dynamic X-axis time labels
                    ctx.textAlign = 'center';
                    ctx.font = '11px monospace';
                    ctx.fillStyle = '#cccccc';

                    // Calculate optimal time intervals based on duration
                    let timeIntervals = [];
                    let timeFormat = '';
                    let intervalMinutes = 0;

                    if (maxTime < 300) { // Less than 5 minutes - show every 30 seconds
                        intervalMinutes = 0.5;
                        timeFormat = 'mm:ss';
                    } else if (maxTime < 1800) { // Less than 30 minutes - show every 2 minutes
                        intervalMinutes = 2;
                        timeFormat = 'mm:ss';
                    } else if (maxTime < 3600) { // Less than 1 hour - show every 5 minutes
                        intervalMinutes = 5;
                        timeFormat = 'HH:mm';
                    } else if (maxTime < 21600) { // Less than 6 hours - show every 30 minutes
                        intervalMinutes = 30;
                        timeFormat = 'HH:mm';
                    } else { // Very long tests - show every hour
                        intervalMinutes = 60;
                        timeFormat = 'HH:mm';
                    }

                    // Generate time labels
                    const numIntervals = Math.min(Math.floor(maxTime / (intervalMinutes * 60)), 8);
                    if (numIntervals > 1) {
                        for (let i = 0; i <= numIntervals; i++) {
                            const timeValue = (maxTime * i) / numIntervals;
                            const x = 40 + (i / numIntervals) * (width - 50);

                            if (i === 0 || i === numIntervals) {
                                // Always show start and end time with date if needed
                                const dataPoint = i === 0 ? this.data[0] : this.data[this.data.length - 1];
                                if (dataPoint && dataPoint.datetime) {
                                    const dateTime = new Date(dataPoint.datetime);
                                    if (maxTime >= 3600) { // More than 1 hour - include date
                                        ctx.fillText(dateTime.toLocaleString('de-DE', {
                                            month: '2-digit',
                                            day: '2-digit',
                                            hour: '2-digit',
                                            minute: '2-digit'
                                        }), x, height - 5);
                                    } else {
                                        ctx.fillText(dateTime.toLocaleTimeString('de-DE'), x, height - 5);
                                    }
                                }
                            } else {
                                // Intermediate time labels
                                const minutes = Math.floor(timeValue / 60);
                                const seconds = Math.floor(timeValue % 60);
                                const hours = Math.floor(minutes / 60);
                                const displayMinutes = minutes % 60;

                                let timeLabel = '';
                                if (maxTime < 3600) {
                                    timeLabel = `${displayMinutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                                } else {
                                    timeLabel = `${hours.toString().padStart(2, '0')}:${displayMinutes.toString().padStart(2, '0')}`;
                                }

                                ctx.fillText(timeLabel, x, height - 5);
                            }
                        }
                    }

                    // Duration and stats in corner
                    ctx.textAlign = 'right';
                    ctx.font = 'bold 14px monospace';

                    // Dynamic duration formatting
                    let durationText = '';
                    if (maxTime < 60) {
                        durationText = `${maxTime.toFixed(0)}s`;
                    } else if (maxTime < 3600) {
                        durationText = `${(maxTime / 60).toFixed(1)} min`;
                    } else {
                        const hours = Math.floor(maxTime / 3600);
                        const minutes = Math.floor((maxTime % 3600) / 60);
                        durationText = `${hours}h ${minutes}m`;
                    }

                    ctx.fillStyle = '#00ff88';
                    ctx.fillText(`‚è± ${durationText}`, width - 10, 20);

                    const currentCapacity = this.data[this.data.length - 1]?.capacity || 0;
                    ctx.fillStyle = '#ffaa00';
                    ctx.fillText(`üîã ${(currentCapacity / 1000).toFixed(2)} Ah`, width - 10, 40);

                    const avgCurrent = this.data.reduce((sum, d) => sum + d.current, 0) / this.data.length;
                    ctx.fillStyle = '#ff00ff';
                    ctx.fillText(`‚ö° ${avgCurrent.toFixed(2)} A`, width - 10, 60);

                    // Add scale indicator for very long tests
                    if (maxTime > 7200) { // More than 2 hours
                        ctx.fillStyle = '#888888';
                        ctx.font = '10px monospace';
                        ctx.fillText(`Scale: 1px = ${(maxTime / (width - 50)).toFixed(1)}s`, width - 10, height - 15);
                    }
                }
        }

        function setPreset(presetName) {
            const preset = presets[presetName];
            if (preset) {
                document.getElementById('batteryType').value = preset.type;
                document.getElementById('dischargeCurrent').value = preset.current;
                document.getElementById('cutoffVoltage').value = preset.cutoff;
                document.getElementById('testCycle').value = 'simple';
                log(`Preset "${presetName}" loaded`, 'info');
            }
        }

        function loadTestCycle() {
            const cycleId = document.getElementById('testCycle').value;
            let cycle = testCycles[cycleId];

            if (cycleId === 'custom' && customCycle) {
                cycle = customCycle;
            }

            if (cycle) {
                currentCycle = cycle;

                // Set parameters from first discharge phase
                const dischargePhase = cycle.phases.find(p => p.type === 'discharge');
                if (dischargePhase) {
                    document.getElementById('dischargeCurrent').value = dischargePhase.current || 1.0;
                    document.getElementById('cutoffVoltage').value = dischargePhase.cutoff || 2.5;
                    document.getElementById('maxTime').value = Math.floor((dischargePhase.maxTime || 0) / 60);
                }

                // Show cycle details
                displayCycleDetails(cycle);

                log(`Test cycle loaded: ${cycle.name}`, 'info');
                log(`Description: ${cycle.description}`, 'info');
                log(`Phases: ${cycle.phases.length}`, 'info');

                // Update status message
                const statusMsg = document.getElementById('statusMessage');
                if (statusMsg) {
                    statusMsg.textContent = `üìã ${cycle.name} - ${cycle.description}`;
                    statusMsg.className = 'info-box';
                }

                // Show edit button for custom
                if (cycleId === 'custom' || cycle.phases.length > 1) {
                    document.getElementById('cycleDetails').style.display = 'block';
                } else {
                    document.getElementById('cycleDetails').style.display = 'none';
                }
            }
        }

        function displayCycleDetails(cycle) {
            const detailsDiv = document.getElementById('cycleDescription');
            const phasesDiv = document.getElementById('cyclePhases');

            detailsDiv.textContent = cycle.description;

            // Display phases
            let phasesHTML = '<div style="margin-top: 10px;">';
            cycle.phases.forEach((phase, index) => {
                phasesHTML += `<div class="phase-item">`;
                phasesHTML += `<div class="phase-header">Phase ${index + 1}: ${phase.name}</div>`;
                phasesHTML += `<div class="phase-details">`;

                if (phase.type === 'rest') {
                    phasesHTML += `<span class="cycle-param">‚è∏Ô∏è Rest: ${phase.duration}s</span>`;
                } else if (phase.type === 'discharge') {
                    phasesHTML += `<span class="cycle-param">‚ö° ${phase.current}A</span>`;
                    if (phase.cutoff) phasesHTML += `<span class="cycle-param">üìâ Cutoff: ${phase.cutoff}V</span>`;
                    if (phase.duration) phasesHTML += `<span class="cycle-param">‚è±Ô∏è ${Math.floor(phase.duration/60)}min</span>`;
                    if (phase.maxTime) phasesHTML += `<span class="cycle-param">‚è±Ô∏è Max: ${Math.floor(phase.maxTime/60)}min</span>`;
                } else if (phase.type === 'ramp') {
                    phasesHTML += `<span class="cycle-param">üìà ${phase.startCurrent}A ‚Üí ${phase.endCurrent}A</span>`;
                    phasesHTML += `<span class="cycle-param">‚è±Ô∏è ${Math.floor(phase.duration/60)}min</span>`;
                }

                phasesHTML += `</div></div>`;
            });
            phasesHTML += '</div>';

            phasesDiv.innerHTML = phasesHTML;
        }

        function toggleCycleEditor() {
            const editor = document.getElementById('cycleEditor');
            const isHidden = editor.style.display === 'none';

            if (isHidden) {
                // Load current cycle into editor
                if (currentCycle) {
                    document.getElementById('customCycleName').value = currentCycle.name;
                    document.getElementById('numPhases').value = currentCycle.phases.length;
                    updatePhaseEditor();

                    // Populate phase data
                    currentCycle.phases.forEach((phase, index) => {
                        populatePhaseFields(index, phase);
                    });
                }
                editor.style.display = 'block';
            } else {
                editor.style.display = 'none';
            }
        }

        function updatePhaseEditor() {
            const numPhases = parseInt(document.getElementById('numPhases').value);
            const editorDiv = document.getElementById('phaseEditor');

            let html = '';
            for (let i = 0; i < numPhases; i++) {
                html += `
                    <div class="phase-item" style="margin: 15px 0;">
                        <div class="phase-header">Phase ${i + 1}</div>
                        <div class="form-group">
                            <label>Phase Name</label>
                            <input type="text" id="phase${i}_name" value="Phase ${i + 1}">
                        </div>
                        <div class="form-group">
                            <label>Type</label>
                            <select id="phase${i}_type" onchange="updatePhaseFields(${i})">
                                <option value="rest">Rest (no load)</option>
                                <option value="discharge" selected>Discharge</option>
                                <option value="ramp">Current Ramp</option>
                            </select>
                        </div>
                        <div id="phase${i}_fields">
                            <div class="form-group">
                                <label>Current (A)</label>
                                <input type="number" id="phase${i}_current" value="1.0" step="0.1" min="0.1" max="20">
                            </div>
                            <div class="form-group">
                                <label>Cutoff Voltage (V)</label>
                                <input type="number" id="phase${i}_cutoff" value="2.5" step="0.1" min="2.0" max="4.2">
                            </div>
                            <div class="form-group">
                                <label>Max Duration (minutes, 0=until cutoff)</label>
                                <input type="number" id="phase${i}_duration" value="0" min="0" max="480">
                            </div>
                        </div>
                    </div>
                `;
            }

            editorDiv.innerHTML = html;
        }

        function updatePhaseFields(phaseIndex) {
            const type = document.getElementById(`phase${phaseIndex}_type`).value;
            const fieldsDiv = document.getElementById(`phase${phaseIndex}_fields`);

            let html = '';
            if (type === 'rest') {
                html = `
                    <div class="form-group">
                        <label>Rest Duration (seconds)</label>
                        <input type="number" id="phase${phaseIndex}_duration" value="60" min="1" max="3600">
                    </div>
                `;
            } else if (type === 'discharge') {
                html = `
                    <div class="form-group">
                        <label>Current (A)</label>
                        <input type="number" id="phase${phaseIndex}_current" value="1.0" step="0.1" min="0.1" max="20">
                    </div>
                    <div class="form-group">
                        <label>Cutoff Voltage (V, optional)</label>
                        <input type="number" id="phase${phaseIndex}_cutoff" value="2.5" step="0.1" min="2.0" max="4.2">
                    </div>
                    <div class="form-group">
                        <label>Duration (minutes, 0=until cutoff)</label>
                        <input type="number" id="phase${phaseIndex}_duration" value="0" min="0" max="480">
                    </div>
                `;
            } else if (type === 'ramp') {
                html = `
                    <div class="form-group">
                        <label>Start Current (A)</label>
                        <input type="number" id="phase${phaseIndex}_startCurrent" value="1.0" step="0.1" min="0.1" max="20">
                    </div>
                    <div class="form-group">
                        <label>End Current (A)</label>
                        <input type="number" id="phase${phaseIndex}_endCurrent" value="2.0" step="0.1" min="0.1" max="20">
                    </div>
                    <div class="form-group">
                        <label>Ramp Duration (minutes)</label>
                        <input type="number" id="phase${phaseIndex}_duration" value="15" min="1" max="60">
                    </div>
                `;
            }

            fieldsDiv.innerHTML = html;
        }

        function populatePhaseFields(phaseIndex, phase) {
            const nameField = document.getElementById(`phase${phaseIndex}_name`);
            const typeField = document.getElementById(`phase${phaseIndex}_type`);

            if (nameField) nameField.value = phase.name;
            if (typeField) {
                typeField.value = phase.type;
                updatePhaseFields(phaseIndex);

                // Populate specific fields
                setTimeout(() => {
                    if (phase.type === 'rest') {
                        const durationField = document.getElementById(`phase${phaseIndex}_duration`);
                        if (durationField) durationField.value = phase.duration || 60;
                    } else if (phase.type === 'discharge') {
                        const currentField = document.getElementById(`phase${phaseIndex}_current`);
                        const cutoffField = document.getElementById(`phase${phaseIndex}_cutoff`);
                        const durationField = document.getElementById(`phase${phaseIndex}_duration`);

                        if (currentField) currentField.value = phase.current || 1.0;
                        if (cutoffField) cutoffField.value = phase.cutoff || 2.5;
                        if (durationField) durationField.value = Math.floor((phase.duration || phase.maxTime || 0) / 60);
                    } else if (phase.type === 'ramp') {
                        const startField = document.getElementById(`phase${phaseIndex}_startCurrent`);
                        const endField = document.getElementById(`phase${phaseIndex}_endCurrent`);
                        const durationField = document.getElementById(`phase${phaseIndex}_duration`);

                        if (startField) startField.value = phase.startCurrent || 1.0;
                        if (endField) endField.value = phase.endCurrent || 2.0;
                        if (durationField) durationField.value = Math.floor((phase.duration || 0) / 60);
                    }
                }, 100);
            }
        }

        function applyCustomCycle() {
            const numPhases = parseInt(document.getElementById('numPhases').value);
            const cycleName = document.getElementById('customCycleName').value || 'Custom Cycle';

            const phases = [];
            for (let i = 0; i < numPhases; i++) {
                const name = document.getElementById(`phase${i}_name`).value;
                const type = document.getElementById(`phase${i}_type`).value;

                const phase = { name, type };

                if (type === 'rest') {
                    phase.duration = parseInt(document.getElementById(`phase${i}_duration`).value);
                } else if (type === 'discharge') {
                    phase.current = parseFloat(document.getElementById(`phase${i}_current`).value);
                    const cutoff = parseFloat(document.getElementById(`phase${i}_cutoff`).value);
                    const duration = parseInt(document.getElementById(`phase${i}_duration`).value);

                    if (cutoff) phase.cutoff = cutoff;
                    if (duration > 0) {
                        phase.maxTime = duration * 60;
                    } else {
                        phase.maxTime = 0;
                    }
                } else if (type === 'ramp') {
                    phase.startCurrent = parseFloat(document.getElementById(`phase${i}_startCurrent`).value);
                    phase.endCurrent = parseFloat(document.getElementById(`phase${i}_endCurrent`).value);
                    phase.duration = parseInt(document.getElementById(`phase${i}_duration`).value) * 60;
                }

                phases.push(phase);
            }

            customCycle = {
                name: cycleName,
                description: `Custom ${numPhases}-phase test cycle`,
                phases: phases
            };

            // Select custom cycle
            document.getElementById('testCycle').value = 'custom';
            loadTestCycle();

            // Hide editor
            document.getElementById('cycleEditor').style.display = 'none';

            log(`Custom cycle created: ${cycleName} with ${numPhases} phases`, 'info');
        }

        function cancelCycleEdit() {
            document.getElementById('cycleEditor').style.display = 'none';
        }

        function log(message, type = 'info') {
            const logDiv = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            const timestamp = new Date().toLocaleTimeString('de-DE');
            entry.textContent = `[${timestamp}] ${message}`;
            logDiv.appendChild(entry);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
            log('Log cleared', 'info');
        }

        async function startTest() {
            if (testRunning) {
                log('‚ö†Ô∏è Test already running - cannot start new test', 'warning');
                return;
            }

            // Double-check device status before starting
            try {
                const statusResponse = await fetch(`${API_BASE}/status`);
                const statusResult = await statusResponse.json();

                if (statusResult.load_on && statusResult.data && statusResult.data.current > 0.01) {
                    log('‚ùå Cannot start test - device is already discharging', 'error');
                    log('   Please stop the current test first', 'warning');
                    return;
                }
            } catch (error) {
                log('‚ö†Ô∏è Could not verify device status - proceeding anyway', 'warning');
            }

            const current = parseFloat(document.getElementById('dischargeCurrent').value);
            const cutoff = parseFloat(document.getElementById('cutoffVoltage').value);
            const maxTime = parseInt(document.getElementById('maxTime').value) * 60;
            const logInterval = parseInt(document.getElementById('logInterval').value) * 1000;

            if (!SIMULATION_MODE) {
                // Real hardware mode
                try {
                    const response = await fetch(`${API_BASE}/start`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            current: current,
                            cutoff: cutoff,
                            maxTime: maxTime
                        })
                    });

                    const result = await response.json();

                    if (!result.success) {
                        log(`Fehler beim Start: ${result.error}`, 'error');
                        return;
                    }

                    testRunning = true;
                    testStartTime = Date.now();
                    dataPoints = [];

                    // Instant button update
                    updateButtonStatesInstant(true);
                    document.getElementById('statusMessage').className = 'info-box';

                    // Enhanced logging with device communication details
                    log(`üöÄ Starting Battery Test...`, 'success');
                    log(`‚öôÔ∏è Parameters: ${current}A, Cutoff: ${cutoff}V, Max Time: ${maxTime}s`, 'info');
                    log(`üì° Sending device configuration commands...`, 'info');
                    log(`‚úì ${result.message}`, 'success');
                    log(`‚è±Ô∏è Test monitoring started`, 'info');

                    // Start polling for status updates
                    statusInterval = setInterval(updateStatus, logInterval);

                } catch (error) {
                    log(`Connection error: ${error.message}`, 'error');
                    log('Is dl24_webserver.py running?', 'warning');
                }

            } else if (SIMULATION_MODE) {
                // Simulation f√ºr Demo
                let simVoltage = 4.2;
                let simCapacity = 0;
                
                testInterval = setInterval(() => {
                    const runtime = (Date.now() - testStartTime) / 1000;
                    
                    // Simulate voltage drop
                    simVoltage -= 0.002;
                    simCapacity += (current / 3600) * (logInterval / 1000) * 1000;
                    
                    const power = simVoltage * current;
                    const resistance = (current > 0.001) ? (simVoltage / current) : 0.0;
                    const energy = (simCapacity * simVoltage) / 1000;

                    updateDisplay(simVoltage, current, power, resistance, simCapacity, energy, 25.0, runtime);
                    dataPoints.push({ time: runtime, voltage: simVoltage, current: current, capacity: simCapacity });
                    
                    if (chart) {
                        chart.data = dataPoints;
                        chart.draw();
                    }
                    
                    // Check cutoff
                    if (simVoltage <= cutoff || (maxTime > 0 && runtime >= maxTime)) {
                        stopTest();
                    }
                }, logInterval);
            } else {
                // Real implementation mit dl24.py
                log('‚ö†Ô∏è Echte Hardware-Kommunikation nicht implementiert in dieser Demo', 'warning');
                log('Bitte dl24.py Backend-Server starten f√ºr echte Tests', 'warning');
            }
        }

        async function stopTest() {
            if (!testRunning) return;

            // Enhanced logging for test stopping
            log(`‚èπÔ∏è Stopping Battery Test...`, 'warning');

            if (!SIMULATION_MODE) {
                // Real hardware mode
                try {
                    log(`üì° Reading final measurements...`, 'info');
                    const response = await fetch(`${API_BASE}/stop`, {
                        method: 'POST'
                    });

                    const result = await response.json();

                    if (result.success) {
                        log(`‚úì ${result.message}`, 'success');
                        log(`‚èπÔ∏è Test monitoring stopped`, 'info');
                    } else {
                        log(`‚úó Error stopping: ${result.error}`, 'error');
                    }
                } catch (error) {
                    log(`‚úó Connection error: ${error.message}`, 'error');
                }

                clearInterval(statusInterval);
            } else {
                clearInterval(testInterval);
                log(`‚úì Simulation stopped`, 'info');
            }

            testRunning = false;

            // Reset load struggle detection
            loadStruggleDetected = false;
            currentHistory = [];
            expectedCurrent = 0;
            hideLoadStruggleWarning();

            // Instant button update
            updateButtonStatesInstant(false);
            document.getElementById('statusMessage').textContent = 'üõë Test completed';
            document.getElementById('statusMessage').className = 'warning-box';

            const capacity = parseFloat(document.getElementById('capacity').textContent);
            const energy = parseFloat(document.getElementById('energy').textContent);

            log(`Test completed - Capacity: ${capacity}mAh, Energy: ${energy}mWh`, 'info');
        }

        function updateDisplay(voltage, current, power, resistance, capacity, energy, temperature, runtime) {
            document.getElementById('voltage').innerHTML = `${voltage.toFixed(3)}<span class="status-unit">V</span>`;
            document.getElementById('current').innerHTML = `${current.toFixed(3)}<span class="status-unit">A</span>`;
            document.getElementById('power').innerHTML = `${power.toFixed(2)}<span class="status-unit">W</span>`;
            document.getElementById('resistance').innerHTML = `${resistance.toFixed(3)}<span class="status-unit">Œ©</span>`;
            document.getElementById('capacity').innerHTML = `${Math.round(capacity)}<span class="status-unit">mAh</span>`;
            document.getElementById('energy').innerHTML = `${Math.round(energy)}<span class="status-unit">mWh</span>`;
            document.getElementById('temperature').innerHTML = `${temperature.toFixed(1)}<span class="status-unit">¬∞C</span>`;
            
            const hours = Math.floor(runtime / 3600);
            const minutes = Math.floor((runtime % 3600) / 60);
            const seconds = Math.floor(runtime % 60);
            document.getElementById('runtime').textContent = 
                `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            const cutoff = parseFloat(document.getElementById('cutoffVoltage').value);
            const startVoltage = dataPoints.length > 0 ? dataPoints[0].voltage : voltage;
            const progress = ((startVoltage - voltage) / (startVoltage - cutoff)) * 100;
            document.getElementById('progressBar').style.width = `${Math.min(progress, 100)}%`;
            document.getElementById('progressBar').textContent = `${Math.round(progress)}%`;
        }

        function exportData() {
            if (dataPoints.length === 0) {
                log('No data to export', 'warning');
                return;
            }

            let csv = 'Time (s),Voltage (V),Current (A),Capacity (mAh)\n';
            dataPoints.forEach(point => {
                csv += `${point.time.toFixed(1)},${point.voltage.toFixed(3)},${point.current.toFixed(3)},${point.capacity.toFixed(1)}\n`;
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `18650_test_${new Date().toISOString().slice(0,10)}.csv`;
            a.click();

            log('Data exported as CSV', 'info');
        }

        // Auto-update cutoff voltage based on battery type
        document.getElementById('batteryType').addEventListener('change', function() {
            const type = this.value;
            if (type === 'liion') {
                document.getElementById('cutoffVoltage').value = 2.5;
            }
            // Keep current value for 'custom'
        });

         // Load Struggle Detection - Improved with stability and hysteresis
        function checkLoadStruggle(current, setCurrent, voltage, cutoffVoltage) {
            if (!testRunning || setCurrent <= 0) {
                loadStruggleDetected = false;
                hideLoadStruggleWarning();
                return;
            }

            // Add current to history
            currentHistory.push({
                current: current,
                timestamp: Date.now()
            });

            // Keep only last 30 seconds of history
            const cutoff = Date.now() - 30000;
            currentHistory = currentHistory.filter(entry => entry.timestamp > cutoff);

            if (currentHistory.length < 20) return; // Need at least 20 samples for stability

            // Calculate average current over last 30 seconds
            const avgCurrent = currentHistory.reduce((sum, entry) => sum + entry.current, 0) / currentHistory.length;

            // More conservative thresholds with hysteresis
            const expectedMinCurrent = setCurrent * 0.80; // 20% tolerance for detection
            const recoveryCurrent = setCurrent * 0.90;   // 10% tolerance for recovery

            // Check if voltage is too low (battery can't deliver current)
            const voltageStruggle = voltage < (cutoffVoltage + 0.3); // Within 0.3V of cutoff

            // Detect load struggle - needs to be persistent
            const currentStruggle = avgCurrent < expectedMinCurrent;

            // For detection: require both conditions OR severe voltage struggle
            const shouldDetectStruggle = (currentStruggle && voltageStruggle) ||
                                       (avgCurrent < setCurrent * 0.7) || // Very low current
                                       (voltage < cutoffVoltage + 0.1);       // Very low voltage

            // For recovery: need better conditions
            const shouldRecover = avgCurrent > recoveryCurrent && voltage > (cutoffVoltage + 0.6);

            if (shouldDetectStruggle && !loadStruggleDetected) {
                loadStruggleDetected = true;
                showLoadStruggleWarning(current, setCurrent, voltage, cutoffVoltage);
            } else if (shouldRecover && loadStruggleDetected) {
                loadStruggleDetected = false;
                hideLoadStruggleWarning();
            }
        }

        function showLoadStruggleWarning(current, setCurrent, voltage, cutoffVoltage) {
            const warning = document.getElementById('loadStruggleWarning');
            const warningText = document.getElementById('loadStruggleText');

            const currentDrop = ((setCurrent - current) / setCurrent * 100).toFixed(1);
            const voltageStatus = voltage < (cutoffVoltage + 0.2) ? 'CRITICAL' : 'WARNING';

            if (voltage < (cutoffVoltage + 0.2)) {
                warningText.textContent = `BATTERY EXHAUSTED! Voltage: ${voltage.toFixed(2)}V (Cut-off: ${cutoffVoltage.toFixed(2)}V)`;
            } else if (voltage < (cutoffVoltage + 0.5)) {
                warningText.textContent = `Low voltage: ${voltage.toFixed(2)}V - Current dropped ${currentDrop}% (Expected: ${setCurrent.toFixed(2)}A)`;
            } else {
                warningText.textContent = `Current dropped ${currentDrop}% - ${current.toFixed(2)}A (Expected: ${setCurrent.toFixed(2)}A) - Check connections!`;
            }

            warning.style.display = 'block';
            log(`‚ö†Ô∏è LOAD STRUGGLE: Current ${current.toFixed(2)}A (expected ${setCurrent.toFixed(2)}A), Voltage ${voltage.toFixed(2)}V`, 'error');
        }

        function hideLoadStruggleWarning() {
            const warning = document.getElementById('loadStruggleWarning');
            warning.style.display = 'none';
            log('‚úÖ Load struggle resolved', 'info');
        }

        // Instant button state updates
        function updateButtonStatesInstant(running) {
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');

            if (running) {
                startBtn.disabled = true;
                stopBtn.disabled = false;
                startBtn.textContent = '‚ñ∂ Start Test';
                stopBtn.textContent = '‚èπ Stop Test';
            } else {
                startBtn.disabled = false;
                stopBtn.disabled = true;
                startBtn.textContent = '‚ñ∂ Start Test';
                stopBtn.textContent = '‚èπ Stop Test';
            }
        }

        // Update chart plotting options
        function updateChartOptions() {
            plotOptions.voltage = document.getElementById('plotVoltage').checked;
            plotOptions.current = document.getElementById('plotCurrent').checked;
            plotOptions.power = document.getElementById('plotPower').checked;
            plotOptions.resistance = document.getElementById('plotResistance').checked;
            plotOptions.capacity = document.getElementById('plotCapacity').checked;
            plotOptions.energy = document.getElementById('plotEnergy').checked;
            plotOptions.temperature = document.getElementById('plotTemperature').checked;

            // Force chart redraw if it exists
            if (chart && chart.data && chart.data.length > 0) {
                chart.draw();
            }
        }

        // Update System Status Display
        function updateSystemStatus(result, data) {
            // Connection status - Check if elements exist before accessing
            const connectionDot = document.getElementById('connectionDot');
            const connectionText = document.getElementById('connectionText');
            if (connectionDot && connectionText) {
                if (result.connected) {
                    connectionDot.className = 'indicator-dot connected';
                    connectionText.textContent = 'Connected';
                } else {
                    connectionDot.className = 'indicator-dot disconnected';
                    connectionText.textContent = 'Disconnected';
                }
            }

            // Load status - Check if elements exist before accessing
            const loadDot = document.getElementById('loadDot');
            const loadText = document.getElementById('loadText');
            if (loadDot && loadText) {
                if (result.load_on) {
                    loadDot.className = 'indicator-dot active';
                    loadText.textContent = 'ON';
                    loadText.style.color = '#ffaa00';
                } else {
                    loadDot.className = 'indicator-dot inactive';
                    loadText.textContent = 'OFF';
                    loadText.style.color = '#666';
                }
            }

            // Test status - Check if elements exist before accessing
            const testDot = document.getElementById('testDot');
            const testStatusText = document.getElementById('testStatusText');
            if (testDot && testStatusText) {
                if (result.running) {
                    testDot.className = 'indicator-dot active';
                    testStatusText.textContent = 'Running';
                    testStatusText.style.color = '#ffaa00';
                } else {
                    testDot.className = 'indicator-dot inactive';
                    testStatusText.textContent = 'Idle';
                    testStatusText.style.color = '#666';
                }
            }

            // Set current and cutoff - Check if elements exist
            const setCurrentText = document.getElementById('setCurrentText');
            const cutoffText = document.getElementById('cutoffText');
            if (setCurrentText) {
                setCurrentText.textContent = result.set_current.toFixed(2) + ' A';
            }
            if (cutoffText) {
                cutoffText.textContent = result.cutoff_voltage.toFixed(2) + ' V';
            }

            // Last update time - Check if element exists
            const lastUpdateText = document.getElementById('lastUpdateText');
            if (lastUpdateText) {
                const now = new Date();
                lastUpdateText.textContent = now.toLocaleTimeString('de-DE');
            }

            // Update button states based on actual device status - Check if buttons exist
            const startBtn = document.getElementById('startBtn');
            const stopBtn = document.getElementById('stopBtn');

            if (startBtn && stopBtn) {
                // Check if load is actually drawing current (ON + current > 0.01A)
                const isActuallyRunning = result.load_on && data.current > 0.01;

                if (isActuallyRunning) {
                    // Device is actively discharging - only show stop button
                    startBtn.disabled = true;
                    stopBtn.disabled = false;
                    startBtn.textContent = '‚ñ∂ Start Test';
                    stopBtn.textContent = '‚èπ Stop Test';

                    // Update testRunning state to match reality
                    if (!testRunning) {
                        testRunning = true;
                        log('üîã Device is actively discharging - test state synchronized', 'info');
                    }
                } else {
                    // Device is idle - show start button
                    if (result.running) {
                        // Backend thinks test is running but device is idle - update backend state
                        testRunning = false;
                        log('‚ö†Ô∏è Test state corrected - device is idle', 'warning');
                    }

                    startBtn.disabled = false;
                    stopBtn.disabled = true;
                    startBtn.textContent = '‚ñ∂ Start Test';
                    stopBtn.textContent = '‚èπ Stop Test';
                }
            }
        }

        async function updateStatus() {
            if (!SIMULATION_MODE) {
                try {
                    const response = await fetch(`${API_BASE}/status`);
                    const result = await response.json();

                    if (result.connected && result.data) {
                        const data = result.data;
                        const runtime = data.runtime;

                        // Update System Status
                        updateSystemStatus(result, data);

                        // Update device status displays
                        document.getElementById('loadStatus').textContent = result.load_on ? 'ON' : 'OFF';
                        document.getElementById('loadStatus').style.color = result.load_on ? '#44ff44' : '#ff4444';
                        document.getElementById('cutoffDisplay').textContent = result.cutoff_voltage.toFixed(2) + 'V';
                        document.getElementById('setCurrentDisplay').textContent = result.set_current.toFixed(2) + 'A';

                        updateDisplay(
                            data.voltage,
                            data.current,
                            data.power,
                            data.resistance,
                            data.capacity,
                            data.energy,
                            data.temperature,
                            runtime
                        );

                        // Check for load struggle
                        checkLoadStruggle(data.current, result.set_current, data.voltage, result.cutoff_voltage);

                        dataPoints.push({
                            time: runtime,
                            voltage: data.voltage,
                            current: data.current,
                            capacity: data.capacity
                        });

                        if (chart) {
                            chart.data = dataPoints;
                            chart.draw();
                        }

                        // Check if test stopped automatically
                        if (!result.running && testRunning) {
                            stopTest();
                        }
                    }
                } catch (error) {
                    log(`Status update failed: ${error.message}`, 'error');
                }
            }
        }

        async function checkConnection() {
            if (!SIMULATION_MODE) {
                try {
                    const response = await fetch(`${API_BASE}/status`);
                    const result = await response.json();

                    if (result.connected) {
                        log('‚úÖ Connected to DL24P', 'info');
                        document.getElementById('statusMessage').textContent = '‚úÖ Connected - Ready for 18650 test';
                        document.getElementById('statusMessage').className = 'info-box';
                    } else {
                        log('‚ö†Ô∏è Device not connected', 'warning');
                        document.getElementById('statusMessage').textContent = '‚ö†Ô∏è Device not connected - Check connection';
                    }
                } catch (error) {
                    log('‚ùå No connection to server', 'error');
                    log('Please start: ./dl24_webserver.py', 'warning');
                    document.getElementById('statusMessage').textContent = '‚ùå Server not reachable';
                    document.getElementById('statusMessage').className = 'warning-box';
                }
            }
        }

        async function refreshPorts() {
            if (SIMULATION_MODE) {
                // Simulation mode - show dummy ports
                const portSelect = document.getElementById('portSelect');
                portSelect.innerHTML = `
                    <option value="/dev/ttyUSB0">/dev/ttyUSB0 (Simulation)</option>
                    <option value="/dev/ttyUSB1">/dev/ttyUSB1 (Simulation)</option>
                `;
                log('üîÑ Port list refreshed (simulation mode)', 'info');
                return;
            }

            try {
                log('üîÑ Refreshing port list...', 'info');
                const response = await fetch(`${API_BASE}/ports`);
                const result = await response.json();

                if (result.success) {
                    const portSelect = document.getElementById('portSelect');
                    portSelect.innerHTML = '';

                    if (result.ports.length === 0) {
                        portSelect.innerHTML = '<option value="">No ports found</option>';
                        log('‚ö†Ô∏è No serial ports detected', 'warning');
                    } else {
                        result.ports.forEach(port => {
                            const option = document.createElement('option');
                            option.value = port.device;
                            option.textContent = `${port.device} - ${port.description}`;

                            // Select current port if it matches
                            if (port.device === result.current.serport) {
                                option.selected = true;
                            }

                            portSelect.appendChild(option);
                        });

                        log(`‚úÖ Found ${result.ports.length} serial port(s)`, 'info');

                        // Show current port
                        if (result.current.serport) {
                            log(`üìå Current port: ${result.current.serport}`, 'info');
                        }
                    }
                } else {
                    log(`‚ùå Failed to list ports: ${result.error}`, 'error');
                    const portSelect = document.getElementById('portSelect');
                    portSelect.innerHTML = '<option value="">Error loading ports</option>';
                }
            } catch (error) {
                log(`‚ùå Error refreshing ports: ${error.message}`, 'error');
                const portSelect = document.getElementById('portSelect');
                portSelect.innerHTML = '<option value="">Server not reachable</option>';
            }
        }

        async function connectToPort() {
            if (SIMULATION_MODE) {
                log('‚úÖ Port connected (simulation mode)', 'info');
                return;
            }

            const portSelect = document.getElementById('portSelect');
            const selectedPort = portSelect.value;

            if (!selectedPort) {
                log('‚ö†Ô∏è Please select a port first', 'warning');
                return;
            }

            try {
                log(`üîå Connecting to ${selectedPort}...`, 'info');

                const response = await fetch(`${API_BASE}/set_port`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ port: selectedPort })
                });

                const result = await response.json();

                if (result.success) {
                    log(`‚úÖ ${result.message}`, 'info');
                    // Refresh connection status
                    setTimeout(() => {
                        checkConnection();
                        updateStatus();
                    }, 500);
                } else {
                    log(`‚ùå Connection failed: ${result.error}`, 'error');
                }
            } catch (error) {
                log(`‚ùå Error connecting to port: ${error.message}`, 'error');
            }
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initChart();
            log('18650 Battery Test Manager started', 'info');

            if (SIMULATION_MODE) {
                log('‚ö†Ô∏è SIMULATION MODE active', 'warning');
                log('System ready for demo tests', 'info');
                refreshPorts();
            } else {
                log('Connecting to backend...', 'info');
                checkConnection();
                refreshPorts();
                // Update status every 2 seconds even when not testing
                setInterval(() => {
                    if (!testRunning) {
                        updateStatus();
                    }
                }, 2000);
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (chart) {
                chart.draw();
            }
        });
    </script>
</body>
</html>
